name: Build and Release KOTORModSync

on:
  release:
    types: [published, prereleased, released, created]
  workflow_dispatch:
    inputs:
      version:
        description: "Version to build (leave empty to use MainConfig.cs version)"
        required: false
        default: ""
  workflow_run:
    workflows: ["Release Please"]
    types:
      - completed

env:
  DOTNET_VERSION: "8.0.x"
  PROJECT_FILE: "KOTORModSync.GUI/KOTORModSync.csproj"
  DOTNET_VERSION_SHORT: "net8.0"  # Specify net8.0 once here, so it's incredibly easy to change to another version globally.
  DOTNET_FRAMEWORK_VERSION_SHORT: "net48"  # Specify net48 once here, so it's incredibly easy to change to another version globally.

jobs:
  determine-version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should_build: ${{ steps.check.outputs.should_build }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5

      - name: Extract Version from MainConfig.cs
        id: extract
        shell: pwsh
        run: |
          $mainConfigPath = "KOTORModSync.Core/MainConfig.cs"
          $content = Get-Content $mainConfigPath -Raw

          if ($content -match 'CurrentVersion\s*=>\s*"([^"]+)"') {
            $codeVersion = $matches[1]
            Write-Host "Found version in MainConfig.cs: $codeVersion"
            echo "code_version=$codeVersion" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "Could not find version in MainConfig.cs"
            echo "code_version=1.0.0" >> $env:GITHUB_OUTPUT
          }

      - name: Determine Version
        id: version
        shell: bash
        run: |
          CODE_VERSION="${{ steps.extract.outputs.code_version }}"

          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
            echo "Using GitHub release tag: $VERSION"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -n "${{ github.event.inputs.version }}" ]; then
              VERSION="${{ github.event.inputs.version }}"
              echo "Using workflow dispatch version: $VERSION"
            else
              VERSION="v${CODE_VERSION}"
              echo "Using MainConfig.cs version: $VERSION"
            fi
          else
            VERSION="v${CODE_VERSION}"
            echo "Using MainConfig.cs version: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Building version: $VERSION"

      - name: Check if Should Build
        id: check
        run: |
          EVENT_NAME="${{ github.event_name }}"
          if [ "$EVENT_NAME" = "release" ] || [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "$EVENT_NAME" = "workflow_run" ]; then
            if [ "${{ github.event.workflow_run.conclusion }}" = "success" ]; then
              echo "Triggered by successful workflow_run (e.g., Release Please)."
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "Workflow run conclusion is not success (got ${{ github.event.workflow_run.conclusion }})."
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          elif [ "$EVENT_NAME" = "pull_request" ]; then
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

  publish-multi-platform:
    name: Publish ${{ matrix.rid }}
    needs: determine-version
    if: needs.determine-version.outputs.should_build == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false  # CRITICAL: Don't cancel other builds if one fails
      matrix:
        include:
          # Windows .NET Framework 4.8 builds (legacy RIDs)
          - rid: win7-x86
            os: windows-latest
            framework: DOTNET_FRAMEWORK_VERSION_SHORT
            platform: x86
          - rid: win7-x64
            os: windows-latest
            framework: DOTNET_FRAMEWORK_VERSION_SHORT
            platform: x64

          # Windows .NET builds (modern RIDs)
          - rid: win-x86
            os: windows-latest
            framework: DOTNET_VERSION_SHORT
            platform: x86
          - rid: win-x64
            os: windows-latest
            framework: DOTNET_VERSION_SHORT
            platform: x64
          - rid: win-arm64
            os: windows-latest
            framework: DOTNET_VERSION_SHORT
            platform: arm64

          # Linux .NET builds
          - rid: linux-x64
            os: ubuntu-latest
            framework: DOTNET_VERSION_SHORT
            platform: x64
          - rid: linux-arm64
            os: ubuntu-latest
            framework: DOTNET_VERSION_SHORT
            platform: arm64

          # macOS .NET builds
          - rid: osx-x64
            os: macos-latest
            framework: DOTNET_VERSION_SHORT
            platform: x64
          - rid: osx-arm64
            os: macos-latest
            framework: DOTNET_VERSION_SHORT
            platform: arm64

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5

      - name: Update Info.plist Version
        if: startsWith(matrix.rid, 'osx-')
        shell: pwsh
        run: |
          $version = "${{ needs.determine-version.outputs.version }}"
          # Remove 'v' prefix if present
          $cleanVersion = $version -replace '^v', ''

          Write-Host "üìù Updating Info.plist to version: $cleanVersion"

          $plistPath = "Info.plist"
          $content = Get-Content $plistPath -Raw

          # Update CFBundleShortVersionString (e.g., v0.10)
          $content = $content -replace '(<key>CFBundleShortVersionString</key>\s*<string>)[^<]+(</string>)', "`$1v$cleanVersion`$2"

          # Update CFBundleVersion (e.g., v0.10.5)
          $content = $content -replace '(<key>CFBundleVersion</key>\s*<string>)[^<]+(</string>)', "`$1v$cleanVersion`$2"

          $content | Out-File -FilePath $plistPath -Encoding UTF8 -NoNewline

          Write-Host "‚úÖ Info.plist updated for ${{ matrix.rid }}"

      - name: Setup MSBuild (Windows/.NET Framework 4.8)
        if: runner.os == 'Windows' && matrix.framework == 'DOTNET_FRAMEWORK_VERSION_SHORT'
        uses: microsoft/setup-msbuild@v2

      - name: Setup .NET 8 SDK
        if: matrix.framework == 'DOTNET_VERSION_SHORT'
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Inject Telemetry Secret
        env:
          TELEMETRY_SECRET: ${{ secrets.KOTORMODSYNC_SIGNING_SECRET }}
        shell: pwsh
        run: |
          Write-Host "üîê Injecting telemetry signing secret..."

          $secretFile = "KOTORModSync.Core/Services/EmbeddedSecrets.cs"
          $dir = Split-Path -Parent $secretFile
          if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
          }

          $content = @"
          // Copyright 2021-2025 KOTORModSync
          // Licensed under the Business Source License 1.1 (BSL 1.1).
          // See LICENSE.txt file in the project root for full license information.

          // AUTO-GENERATED FILE - DO NOT COMMIT
          // Generated: $((Get-Date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss UTC"))

          namespace KOTORModSync.Core.Services
          {
              internal static class EmbeddedSecrets
              {
                  internal const string TELEMETRY_SIGNING_KEY = "$env:TELEMETRY_SECRET";
              }
          }
          "@

          $content | Out-File -FilePath $secretFile -Encoding UTF8 -NoNewline
          Write-Host "‚úÖ Secret injected for ${{ matrix.rid }}"

      - name: Restore Dependencies (Windows - MSBuild for .NET Framework 4.8)
        if: runner.os == 'Windows' && matrix.framework == 'DOTNET_FRAMEWORK_VERSION_SHORT'
        run: msbuild KOTORModSync.sln /t:Restore /p:TargetFramework=${{ matrix.framework }} /p:Configuration=Release

      - name: Restore Dependencies (dotnet CLI for .NET 8.0)
        if: matrix.framework == 'DOTNET_VERSION_SHORT'
        run: dotnet restore KOTORModSync.sln /p:TargetFramework=${{ matrix.framework == 'DOTNET_VERSION_SHORT' && env.DOTNET_VERSION_SHORT || matrix.framework }} /p:Configuration=Release

      - name: Publish ${{ matrix.rid }} (Windows - MSBuild for .NET Framework 4.8)
        if: runner.os == 'Windows' && matrix.framework == 'DOTNET_FRAMEWORK_VERSION_SHORT'
        shell: pwsh
        run: |
          Write-Host "üî® Publishing ${{ matrix.rid }} using MSBuild (.NET Framework 4.8)..."
          msbuild ${{ env.PROJECT_FILE }} `
            /t:Publish `
            /p:Configuration=Release `
            /p:TargetFramework=${{ matrix.framework == 'DOTNET_FRAMEWORK_VERSION_SHORT' && env.DOTNET_FRAMEWORK_VERSION_SHORT || matrix.framework }} `
            /p:RuntimeIdentifier=${{ matrix.rid }} `
            /p:SelfContained=true `
            /p:Platform=${{ matrix.platform }} `
            /p:PublishSingleFile=false `
            /p:PublishReadyToRun=true `
            /p:PublishTrimmed=false `
            /p:DefineConstants="OFFICIAL_BUILD" `
            /p:PublishDir="$PWD/publish/${{ matrix.rid }}/"
          Write-Host "‚úÖ Published ${{ matrix.rid }}"

      - name: Publish ${{ matrix.rid }} (dotnet CLI for .NET 8.0)
        if: matrix.framework == 'DOTNET_VERSION_SHORT'
        shell: pwsh
        run: |
          Write-Host "üî® Publishing ${{ matrix.rid }} using dotnet CLI (.NET 8)..."
          dotnet publish ${{ env.PROJECT_FILE }} `
            -c Release `
            --framework ${{ matrix.framework == 'DOTNET_VERSION_SHORT' && env.DOTNET_VERSION_SHORT || matrix.framework }} `
            --runtime ${{ matrix.rid }} `
            --self-contained true `
            -p:Platform=${{ matrix.platform }} `
            -p:PublishSingleFile=false `
            -p:PublishReadyToRun=true `
            -p:PublishTrimmed=false `
            -p:DefineConstants="OFFICIAL_BUILD" `
            -o ./publish/${{ matrix.rid }}
          Write-Host "‚úÖ Published ${{ matrix.rid }}"

      - name: Prepare Release Package
        shell: pwsh
        run: |
          $publishDir = "./publish/${{ matrix.rid }}"
          $version = "${{ needs.determine-version.outputs.version }}"
          $packageRoot = "./package/${{ matrix.rid }}"
          $packageDir = "$packageRoot/KOTORModSync $version"

          Write-Host "üì¶ Preparing release package for ${{ matrix.rid }} version $version..."

          # Create package directory structure
          New-Item -ItemType Directory -Path "$packageRoot" -Force | Out-Null
          New-Item -ItemType Directory -Path "$packageDir" -Force | Out-Null
          New-Item -ItemType Directory -Path "$packageDir/docs" -Force | Out-Null

          # Copy application files
          Copy-Item -Path "$publishDir/*" -Destination "$packageDir/" -Recurse -Force

          # Copy Info.plist for macOS builds
          if ("${{ matrix.rid }}" -like "osx-*") {
            if (Test-Path "Info.plist") {
              Copy-Item "Info.plist" "$packageDir/"
              Write-Host "‚úÖ Copied Info.plist for macOS build"
            }
          }

          # Copy documentation
          if (Test-Path "LICENSE.txt") {
            Copy-Item "LICENSE.txt" "$packageDir/docs/"
          }
          if (Test-Path "KOTORModSync - Official Documentation.txt") {
            Copy-Item "KOTORModSync - Official Documentation.txt" "$packageDir/docs/"
          }
          if (Test-Path "TELEMETRY_SETUP_GUIDE.md") {
            Copy-Item "TELEMETRY_SETUP_GUIDE.md" "$packageDir/docs/"
          }
          if (Test-Path "README.md") {
            Copy-Item "README.md" "$packageDir/docs/"
          }

          Write-Host "‚úÖ Package prepared: $packageDir"

      - name: Create Archive (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $packageDir = "./package/${{ matrix.rid }}/KOTORModSync ${{ needs.determine-version.outputs.version }}"
          $version = "${{ needs.determine-version.outputs.version }}"
          $archiveName = "KOTORModSync-$version-${{ matrix.rid }}.zip"

          Write-Host "üóúÔ∏è Creating archive: $archiveName"

          Compress-Archive -Path "$packageDir" -DestinationPath $archiveName -Force

          Write-Host "‚úÖ Archive created: $archiveName"
          Write-Host "üìä Archive size: $((Get-Item $archiveName).Length / 1MB) MB"

      - name: Create Archive (Linux/macOS)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          version="${{ needs.determine-version.outputs.version }}"
          archive_name="KOTORModSync-$version-${{ matrix.rid }}.zip"

          echo "üóúÔ∏è Creating archive: $archive_name"

          cd "package/${{ matrix.rid }}"
          zip -r "../../$archive_name" "KOTORModSync $version"
          cd ../..

          echo "‚úÖ Archive created: $archive_name"
          echo "üìä Archive size: $(du -h $archive_name | cut -f1)"

      - name: Upload Release Artifact
        uses: actions/upload-artifact@v4
        with:
          name: KOTORModSync-${{ needs.determine-version.outputs.version }}-${{ matrix.rid }}
          path: KOTORModSync-${{ needs.determine-version.outputs.version }}-${{ matrix.rid }}.zip
          retention-days: 90
          compression-level: 0

      - name: Upload to GitHub Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: KOTORModSync-${{ needs.determine-version.outputs.version }}-${{ matrix.rid }}.zip
          tag_name: ${{ needs.determine-version.outputs.version }}
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-appcast:
    name: Generate AppCast
    needs: [determine-version, publish-multi-platform]
    # Run even if some builds failed (but not if all were cancelled/skipped)
    if: needs.determine-version.outputs.should_build == 'true' && !cancelled()
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: master  # Checkout master branch instead of detached HEAD
          fetch-depth: 0  # Fetch full history for proper git operations

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install NetSparkle AppCast Generator
        run: dotnet tool install --global NetSparkleUpdater.Tools.AppCastGenerator

      - name: Download All Release Artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          pattern: KOTORModSync-${{ needs.determine-version.outputs.version }}-*

      - name: List Downloaded Artifacts
        run: |
          echo "üì¶ Downloaded artifacts:"
          ls -lah artifacts/

      - name: Generate AppCast Signatures
        env:
          NETSPARKLE_PRIVATE_KEY: ${{ secrets.NETSPARKLE_PRIVATE_KEY }}
        shell: bash
        run: |
          echo "üîê Generating signatures for release files..."

          # Create temp directory for key
          mkdir -p ~/.netsparkle
          echo "$NETSPARKLE_PRIVATE_KEY" > ~/.netsparkle/NetSparkle_Ed25519.priv
          chmod 600 ~/.netsparkle/NetSparkle_Ed25519.priv

          # Create signatures directory
          mkdir -p signatures

          # Generate signature for each platform
          for artifact_dir in artifacts/KOTORModSync-*; do
            if [ -d "$artifact_dir" ]; then
              for zip_file in "$artifact_dir"/*.zip; do
                if [ -f "$zip_file" ]; then
                  filename=$(basename "$zip_file")
                  echo "Signing: $filename"

                  # Generate signature using NetSparkle
                  signature=$(netsparkle-generate-appcast --generate-signature "$zip_file")
                  echo "$signature" > "signatures/${filename}.signature"

                  echo "‚úì Signature generated for $filename"
                fi
              done
            fi
          done

          echo "‚úÖ All signatures generated"

      - name: Update AppCast XML
        shell: bash
        run: |
          version="${{ needs.determine-version.outputs.version }}"
          clean_version="${version#v}"  # Remove 'v' prefix

          echo "üìù Updating appcast.xml for version $version"

          # Backup existing appcast
          cp appcast.xml appcast.xml.bak

          # Get current date in RFC 822 format
          pub_date=$(date -R)

          # Start building new appcast
          cat > appcast.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">
              <channel>
                  <title>KOTORModSync Updates</title>
                  <link>https://github.com/th3w1zard1/KOTORModSync</link>
                  <description>Update feed for KOTORModSync</description>
                  <language>en</language>
          EOF

          # Add item for each platform
          for artifact_dir in artifacts/KOTORModSync-*; do
            if [ -d "$artifact_dir" ]; then
              for zip_file in "$artifact_dir"/*.zip; do
                if [ -f "$zip_file" ]; then
                  filename=$(basename "$zip_file")
                  filesize=$(stat -c%s "$zip_file" 2>/dev/null || stat -f%z "$zip_file")

                  # Extract RID from filename (e.g., win-x64 from KOTORModSync-v1.0.0-win-x64.zip)
                  rid=$(echo "$filename" | sed -E 's/.*-([^-]+-[^.]+)\.zip/\1/')

                  # Determine OS from RID
                  case "$rid" in
                    win*)
                      os="windows"
                      ;;
                    linux-*)
                      os="linux"
                      ;;
                    osx-*)
                      os="macos"
                      ;;
                    *)
                      os="windows"
                      ;;
                  esac

                  # Read signature
                  signature=$(cat "signatures/${filename}.signature")

                  # Add item to appcast
                  cat >> appcast.xml << ITEM

                  <!-- $rid -->
                  <item>
                      <title>Version $clean_version ($rid)</title>
                      <sparkle:releaseNotesLink>https://github.com/th3w1zard1/KOTORModSync/releases/tag/$version</sparkle:releaseNotesLink>
                      <pubDate>$pub_date</pubDate>
                      <enclosure
                          url="https://github.com/th3w1zard1/KOTORModSync/releases/download/$version/$filename"
                          sparkle:version="$clean_version"
                          sparkle:os="$os"
                          length="$filesize"
                          type="application/octet-stream"
                          sparkle:edSignature="$signature" />
                  </item>
          ITEM
                fi
              done
            fi
          done

          # Close XML
          cat >> appcast.xml << 'EOF'
              </channel>
          </rss>
          EOF

          echo "‚úÖ AppCast updated"
          cat appcast.xml

      - name: Check if Release Exists
        id: check_release
        if: github.event_name == 'workflow_run'
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          version="${{ needs.determine-version.outputs.version }}"
          echo "üîç Checking if release exists for version: $version"

          # Check if release exists using GitHub API
          response=$(curl -s -w "\n%{http_code}" \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$version")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          if [ "$http_code" = "200" ]; then
            echo "‚úÖ Release exists for version $version"
            echo "release_exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Release does not exist for version $version (HTTP $http_code)"
            echo "release_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and Push AppCast
        if: github.event_name == 'release' || (github.event_name == 'workflow_run' && steps.check_release.outputs.release_exists == 'true')
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Ensure we're on master branch, forcibly resetting if needed
          # Use -B flag to create branch if it doesn't exist, or reset if it does
          git checkout -B master origin/master || git checkout -B master
          
          git add appcast.xml

          if git diff --staged --quiet; then
            echo "No changes to appcast.xml"
          else
            git commit -m "Update appcast.xml for ${{ needs.determine-version.outputs.version }}"
            git push origin master
          fi

      - name: Upload AppCast to Release
        if: github.event_name == 'release' || (github.event_name == 'workflow_run' && steps.check_release.outputs.release_exists == 'true')
        uses: softprops/action-gh-release@v2
        with:
          files: appcast.xml
          tag_name: ${{ needs.determine-version.outputs.version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

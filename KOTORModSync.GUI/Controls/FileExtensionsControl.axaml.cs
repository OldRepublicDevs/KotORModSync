// Copyright 2021-2025 KOTORModSync
// Licensed under the GNU General Public License v3.0 (GPLv3).
// See LICENSE.txt file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Linq;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Markup.Xaml;
using Avalonia.Threading;
using Avalonia.VisualTree;
using JetBrains.Annotations;
using KOTORModSync.Core;

namespace KOTORModSync.Controls
{
    public partial class FileExtensionsControl : UserControl
    {
        public static readonly StyledProperty<List<string>> FileExtensionsProperty =
            AvaloniaProperty.Register<FileExtensionsControl, List<string>>(nameof(FileExtensions), new List<string>());

        private bool _isUpdatingFromTextBox; // Re-entrancy guard

        public List<string> FileExtensions
        {
            get => GetValue(FileExtensionsProperty);
            set => SetValue(FileExtensionsProperty, value);
        }

        public FileExtensionsControl()
        {
            // This method is typically auto-generated by the XAML compiler
            // Adding a manual implementation as a temporary fix
            AvaloniaXamlLoader.Load(this);
            UpdateEmptyStateVisibility();
        }

        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
        {
            base.OnPropertyChanged(change);

            if ( change.Property != FileExtensionsProperty )
		        return;

            // Don't update display if we're in the middle of updating from a TextBox
            if (_isUpdatingFromTextBox)
                return;

            // Don't update if the control isn't fully loaded yet
            var extensionsItemsControl = this.FindControl<ItemsControl>("ExtensionsItemsControl");
            var emptyStateBorder = this.FindControl<Border>("EmptyStateBorder");
            if (extensionsItemsControl == null || emptyStateBorder == null)
                return;

            UpdateExtensionsDisplay();
            UpdateEmptyStateVisibility();
        }

        private void UpdateExtensionsDisplay()
        {
            var extensionsItemsControl = this.FindControl<ItemsControl>("ExtensionsItemsControl");
	        if ( extensionsItemsControl?.ItemsSource == FileExtensions )
			    return;
	        if (extensionsItemsControl != null)
		        extensionsItemsControl.ItemsSource = FileExtensions;
        }

        private void UpdateEmptyStateVisibility()
        {
            var emptyStateBorder = this.FindControl<Border>("EmptyStateBorder");
	        if ( emptyStateBorder == null )
			    return;
	        emptyStateBorder.IsVisible = FileExtensions == null || FileExtensions.Count == 0;
        }

        private void AddExtension_Click(object sender, RoutedEventArgs e)
        {
            if (FileExtensions == null)
                FileExtensions = new List<string>();

            // User-initiated action, allow full update cycle
            _isUpdatingFromTextBox = false;

            // Create a new list to ensure property change notification
            var newList = new List<string>(FileExtensions) { string.Empty };
            FileExtensions = newList;

            // Focus the newly added textbox
            Dispatcher.UIThread.Post(() =>
            {
                try
                {
                    var textBoxes = this.GetVisualDescendants().OfType<TextBox>().ToList();
                    TextBox lastTextBox = textBoxes.LastOrDefault();
					_ = (lastTextBox?.Focus());
                }
                catch (Exception ex)
                {
                    Logger.LogException(ex, "Error focusing newly added TextBox in FileExtensionsControl");
                }
            }, DispatcherPriority.Input);
        }

        private void RemoveExtension_Click(object sender, RoutedEventArgs e)
        {
	        if ( !(sender is Button button) || FileExtensions == null )
			    return;

	        // Find the parent Grid, then the Border to get the associated TextBox
	        if ( !(button.Parent is Grid parentGrid) )
		        return;

	        TextBox textBox = parentGrid.GetVisualDescendants().OfType<TextBox>().FirstOrDefault();
	        if ( textBox == null )
		        return;

	        int index = GetTextBoxIndex(textBox);
	        if ( index < 0 || index >= FileExtensions.Count )
		        return;

	        // User-initiated action, allow full update cycle
	        _isUpdatingFromTextBox = false;

	        // Create a new list to ensure property change notification
	        var newList = new List<string>(FileExtensions);
	        newList.RemoveAt(index);
	        FileExtensions = newList;
        }

        private void ExtensionTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
	        if ( !(sender is TextBox textBox) || FileExtensions == null )
			    return;
	        // Find the index of this textbox in the list
	        int index = GetTextBoxIndex(textBox);
	        if ( index < 0 || index >= FileExtensions.Count )
			    return;

	        string newText = textBox.Text ?? string.Empty;

	        // Only update if the value actually changed to prevent infinite loop
	        if ( FileExtensions[index] == newText )
	        {
				UpdateExtensionValidation(textBox);
		        return;
	        }

	        // Set re-entrancy guard to prevent OnPropertyChanged from updating display
	        _isUpdatingFromTextBox = true;
	        try
	        {
		        // Create a new list to ensure property change notification
		        var newList = new List<string>(FileExtensions)
				{
					[index] = newText
				};
		        FileExtensions = newList;
	        }
	        finally
	        {
		        _isUpdatingFromTextBox = false;
	        }

			UpdateExtensionValidation(textBox);
        }

        private int GetTextBoxIndex(TextBox textBox)
        {
            var extensionsItemsControl = this.FindControl<ItemsControl>("ExtensionsItemsControl");
	        if ( extensionsItemsControl == null || !(extensionsItemsControl.ItemsSource is List<string> extensions) || textBox == null )
			    return -1;
	        try
            {
	            var textBoxes = this.GetVisualDescendants().OfType<TextBox>().ToList();
	            int index = textBoxes.IndexOf(textBox);
	            return index >= 0 && index < extensions.Count ? index : -1;
            }
            catch (Exception ex)
            {
	            Logger.LogException(ex, "Error getting TextBox index in FileExtensionsControl");
	            return -1;
            }
        }

        private void ExtensionTextBox_KeyDown(object sender, KeyEventArgs e)
        {
            switch (e.Key)
            {
                case Key.Enter:
                    // Add a new extension when Enter is pressed
                    AddExtension_Click(sender, e);
                    e.Handled = true;
                    break;
                case Key.Delete when sender is TextBox deleteTextBox &&
                                     FileExtensions != null && string.IsNullOrWhiteSpace(deleteTextBox.Text):
                    {
                        // Remove empty extension when Delete is pressed on empty textbox
                        int index = GetTextBoxIndex(deleteTextBox);
                        if (index >= 0 && index < FileExtensions.Count)
                        {
                            // User-initiated action, allow full update cycle
                            _isUpdatingFromTextBox = false;

                            // Create a new list to ensure property change notification
                            var newList = new List<string>(FileExtensions);
                            newList.RemoveAt(index);
                            FileExtensions = newList;
                        }
                        e.Handled = true;
                        break;
                    }
            }
        }

        private static void UpdateExtensionValidation(TextBox textBox)
        {
            if (textBox == null)
                return;

            string extension = textBox.Text?.Trim() ?? string.Empty;
            bool isValid = string.IsNullOrWhiteSpace(extension) || IsValidExtension(extension);

            // Update visual styling based on validation
            if (string.IsNullOrWhiteSpace(extension))
            {
                // Reset to default styling for empty extensions
                textBox.ClearValue(BorderBrushProperty);
                textBox.ClearValue(BorderThicknessProperty);
                ToolTip.SetTip(textBox, null);
            }
            else if (isValid)
            {
                // Valid extension - green border
                textBox.BorderBrush = ThemeResourceHelper.UrlValidationValidBrush;
                textBox.BorderThickness = new Thickness(1);
                ToolTip.SetTip(textBox, "Valid file extension");
            }
            else
            {
                // Invalid extension - red border
                textBox.BorderBrush = ThemeResourceHelper.UrlValidationInvalidBrush;
                textBox.BorderThickness = new Thickness(2);
                ToolTip.SetTip(textBox, $"Invalid file extension: {extension}");
            }
        }

        /// <summary>
        /// Checks if a string is a valid file extension
        /// </summary>
        private static bool IsValidExtension(string extension)
        {
            if (string.IsNullOrWhiteSpace(extension))
                return false;

			// Basic extension validation - should start with a dot and contain only valid characters
			if ( extension.ToCharArray()[0] != '.' )
                return false;

            // Check for valid extension characters (letters, numbers, some special chars)
            string extensionWithoutDot = extension.Substring(1);
            if (extensionWithoutDot.Length == 0)
                return false;

            foreach (char c in extensionWithoutDot)
            {
                if (!char.IsLetterOrDigit(c) && c != '_' && c != '-')
                    return false;
            }

            return true;
        }

        // Public methods for external access
        public void SetExtensions([NotNull] IEnumerable<string> extensions)
        {
            var extensionsList = extensions?.ToList() ?? new List<string>();
            Logger.LogVerbose($"FileExtensionsControl.SetExtensions called with {extensionsList.Count} extensions: [{string.Join(", ", extensionsList)}]");

            // Ensure the control is loaded before setting data
            var extensionsItemsControl = this.FindControl<ItemsControl>("ExtensionsItemsControl");
            var emptyStateBorder = this.FindControl<Border>("EmptyStateBorder");
            if (extensionsItemsControl == null || emptyStateBorder == null)
            {
                Logger.LogVerbose("FileExtensionsControl not fully loaded yet, deferring SetExtensions");
                // Defer the update until the control is loaded
                this.Loaded += (sender, e) =>
                {
                    Logger.LogVerbose($"FileExtensionsControl loaded, now setting {extensionsList.Count} extensions");
                    FileExtensions = extensionsList;
                };
                return;
            }

            Logger.LogVerbose("FileExtensionsControl already loaded, setting extensions immediately");
            FileExtensions = extensionsList;
        }

        public List<string> GetValidExtensions()
        {
            if (FileExtensions == null)
                return new List<string>();

            var validExtensions = new List<string>();
            foreach (string extension in FileExtensions)
            {
                if (!string.IsNullOrWhiteSpace(extension))
                {
                    string cleanedExtension = extension.Trim();
                    if (!cleanedExtension.StartsWith("."))
                    {
                        cleanedExtension = "." + cleanedExtension;
                    }
                    validExtensions.Add(cleanedExtension);
                }
            }
            return validExtensions;
        }
    }
}

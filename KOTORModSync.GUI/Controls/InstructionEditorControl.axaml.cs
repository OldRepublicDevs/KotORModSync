// Copyright 2021-2025 KOTORModSync
// Licensed under the GNU General Public License v3.0 (GPLv3).
// See LICENSE.txt file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Linq;
using Avalonia.Controls;
using Avalonia.Interactivity;
using Avalonia.Markup.Xaml;
using Avalonia.Threading;
using JetBrains.Annotations;
using KOTORModSync.Core;

namespace KOTORModSync.Controls
{
	public partial class InstructionEditorControl : UserControl
	{
		public InstructionEditorControl()
		{
			// This method is typically auto-generated by the XAML compiler
			// Adding a manual implementation as a temporary fix
			AvaloniaXamlLoader.Load(this);

			// Add event handler for when the control is loaded
			this.Loaded += (sender, e) => UpdateFileExtensionsControl();
		}

		private static readonly char[] separator = new[] { ' ', ',', ';', '\n', '\r' };

		public event EventHandler<RoutedEventArgs> AddNewInstruction;
		public event EventHandler<RoutedEventArgs> DeleteInstruction;
		public event EventHandler<RoutedEventArgs> MoveInstructionUp;
		public event EventHandler<RoutedEventArgs> MoveInstructionDown;
		public event EventHandler<RoutedEventArgs> BrowseSourceFiles;
		public event EventHandler<RoutedEventArgs> BrowseSourceFromFolders;
		public event EventHandler<RoutedEventArgs> BrowseDestination;

		private void AddNewInstruction_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) => AddNewInstruction?.Invoke(sender, e);

		private void DeleteInstruction_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) => DeleteInstruction?.Invoke(sender, e);

		private void MoveInstructionUp_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) => MoveInstructionUp?.Invoke(sender, e);

		private void MoveInstructionDown_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) => MoveInstructionDown?.Invoke(sender, e);

		private void BrowseSourceFiles_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) => BrowseSourceFiles?.Invoke(sender, e);

		private void BrowseSourceFromFolders_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) => BrowseSourceFromFolders?.Invoke(sender, e);

		private void BrowseDestination_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) => BrowseDestination?.Invoke(sender, e);

		protected override void OnDataContextChanged(EventArgs e)
		{
			base.OnDataContextChanged(e);
			// Use Dispatcher to ensure the control is fully loaded
			Dispatcher.UIThread.Post(() => UpdateFileExtensionsControl(), DispatcherPriority.Loaded);
		}

		private void UpdateFileExtensionsControl()
		{
			if (DataContext is Instruction instruction && instruction.Action == Instruction.ActionType.DelDuplicate)
			{
				// Parse the Arguments string into individual extensions
				List<string> extensions = ParseExtensionsFromArguments(instruction.Arguments);
				Logger.LogVerbose($"InstructionEditorControl.UpdateFileExtensionsControl: Arguments='{instruction.Arguments}', Parsed extensions: [{string.Join(", ", extensions)}]");
				var fileExtensionsControl = this.FindControl<FileExtensionsControl>("FileExtensionsControl");
				if (fileExtensionsControl != null)
				{
					Logger.LogVerbose("Found FileExtensionsControl, calling SetExtensions");
					fileExtensionsControl.SetExtensions(extensions);
				}
				else
				{
					Logger.LogVerbose("FileExtensionsControl not found!");
				}
			}
		}

		private static List<string> ParseExtensionsFromArguments([NotNull] string arguments)
		{
			if (string.IsNullOrWhiteSpace(arguments))
				return new List<string>(); // Return empty list, not default extension

			// Split by common delimiters and clean up
			var extensions = arguments.Split(separator, StringSplitOptions.RemoveEmptyEntries)
				.Where(ext => !string.IsNullOrWhiteSpace(ext))
				.Select(ext => ext.Trim())
				.ToList();

			return extensions;
		}

		public void SyncExtensionsToArguments()
		{
			if (DataContext is Instruction instruction && instruction.Action == Instruction.ActionType.DelDuplicate)
			{
				var fileExtensionsControl = this.FindControl<FileExtensionsControl>("FileExtensionsControl");
				var extensions = fileExtensionsControl?.GetValidExtensions() ?? new List<string>();
				instruction.Arguments = string.Join(" ", extensions.Where(ext => !string.IsNullOrWhiteSpace(ext)));
			}
		}

		private void OnInstructionArgumentsChanged()
		{
			// Update the FileExtensionsControl when Arguments property changes
			Dispatcher.UIThread.Post(() => UpdateFileExtensionsControl(), DispatcherPriority.Loaded);
		}
	}
}

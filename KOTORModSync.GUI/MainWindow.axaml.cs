// Copyright 2021-2025 KOTORModSync
// Licensed under the Business Source License 1.1 (BSL 1.1).
// See LICENSE.txt file in the project root for full license information.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.LogicalTree;
using Avalonia.Media;
using Avalonia.Platform.Storage;
using Avalonia.Threading;
using Avalonia.VisualTree;
using JetBrains.Annotations;
using KOTORModSync.CallbackDialogs;
using KOTORModSync.Controls;
using KOTORModSync.Converters;
using KOTORModSync.Core;
using KOTORModSync.Core.CLI;
using KOTORModSync.Models;
using KOTORModSync.Services;
using KOTORModSync.Core.FileSystemUtils;
using KOTORModSync.Core.Services;
using KOTORModSync.Core.Utility;
using KOTORModSync.Dialogs;
using ReactiveUI;
using SharpCompress.Archives;
using static KOTORModSync.Core.Services.ModManagementService;
using NotNullAttribute = JetBrains.Annotations.NotNullAttribute;
using FileLoadingService = KOTORModSync.Core.Services.FileLoadingService;

namespace KOTORModSync
{
	[SuppressMessage(category: "ReSharper", checkId: "UnusedParameter.Local")]
	public sealed partial class MainWindow : Window
	{
		public static readonly DirectProperty<MainWindow, ModComponent> CurrentComponentProperty =
			AvaloniaProperty.RegisterDirect<MainWindow, ModComponent>(
				nameof(CurrentComponent),
				o => (o?.CurrentComponent),
				(o, v) => o.CurrentComponent = v
			);
		private bool _ignoreWindowMoveWhenClickingComboBox;
		private bool _initialize = true;
		private bool _installRunning;
		private bool _mouseDownForWindowMoving;
		private PointerPoint _originalPoint;
		private OutputWindow _outputWindow;
		private bool _progressWindowClosed;
		private string _searchText;
		private CancellationTokenSource _modSuggestCts;
		private CancellationTokenSource _installSuggestCts;
		private bool _suppressPathEvents;
		private bool _suppressComboEvents;
		private bool _suppressComponentCheckboxEvents;
		private bool? _rootSelectionState;
		private bool _editorMode;
		private bool _spoilerFreeMode;
		private bool _isClosingProgressWindow;
		private string _lastLoadedFileName;

		public static bool HasFetchedDownloads { get; private set; } = false;

		private DispatcherTimer _downloadAnimationTimer;
		private int _downloadAnimationDots;

		private readonly ModManagementService _modManagementService;

		public ModManagementService ModManagementService => _modManagementService;

		private readonly DownloadCacheService _downloadCacheService;

		public DownloadCacheService DownloadCacheService => _downloadCacheService;

		private readonly ModListService _modListService;
		private readonly ValidationService _validationService;
		private readonly UIStateService _uiStateService;
		private readonly InstructionManagementService _instructionManagementService;
		private readonly SelectionService _selectionService;
		private readonly FileSystemService _fileSystemService;
		private readonly GuiPathService _guiPathService;
		private readonly DialogService _dialogService;
		private readonly MenuBuilderService _menuBuilderService;
		private readonly DragDropService _dragDropService;
		private readonly KOTORModSync.Services.FileLoadingService _fileLoadingService;
		private readonly Services.ComponentEditorService _componentEditorService;
		private readonly ComponentSelectionService _componentSelectionService;
		private readonly DownloadOrchestrationService _downloadOrchestrationService;
		private readonly FilterUIService _filterUIService;
		private readonly MarkdownRenderingService _markdownRenderingService;
		private readonly InstructionBrowsingService _instructionBrowsingService;
		private readonly InstructionGenerationService _instructionGenerationService;
		private readonly ValidationDisplayService _validationDisplayService;
		private readonly SettingsService _settingsService;
		private readonly StepNavigationService _stepNavigationService;

		private readonly KOTORModSync.Core.Services.TelemetryService _telemetryService;

		// Note: ModListSidebar is now auto-generated by Avalonia from x:Name attribute in the XAML
		private ListBox ModListBox => ModListSidebar?.ModListBox;
		public bool IsClosingMainWindow;
		public bool? RootSelectionState
		{
			get => _rootSelectionState;
			set
			{
				if ( _rootSelectionState == value ) return;

				_suppressSelectAllCheckBoxEvents = true;

				try
				{

					_ = SetAndRaise(RootSelectionStateProperty, ref _rootSelectionState, value);

					_componentSelectionService.HandleSelectAllCheckbox(value, ComponentCheckboxChecked, ComponentCheckboxUnchecked);

					UpdateModCounts();
					UpdateStepProgress();
					ResetDownloadStatusDisplay();
				}
				finally
				{
					_suppressSelectAllCheckBoxEvents = false;
				}
			}
		}
		public bool EditorMode
		{
			get => _editorMode;
			set
			{
				if ( _editorMode == value ) return;
				_ = SetAndRaise(EditorModeProperty, ref _editorMode, value);
				UpdateMenuVisibility();
				RefreshModListItems();
				BuildGlobalActionsMenu();
				UpdateStepProgress();
				RefreshModListVisuals();
			}
		}

		public static readonly DirectProperty<MainWindow, bool> EditorModeProperty =
			AvaloniaProperty.RegisterDirect<MainWindow, bool>(
				nameof(EditorMode),
				o => o._editorMode,
				(o, v) => o.EditorMode = v
			);

		public bool SpoilerFreeMode
		{
			get => _spoilerFreeMode;
			set
			{
				if ( _spoilerFreeMode == value ) return;
				_ = SetAndRaise(SpoilerFreeModeProperty, ref _spoilerFreeMode, value);
				RefreshModListItems();
				RefreshModListVisuals();

				// Re-render markdown content if a component is selected
				if ( CurrentComponent != null )
				{
					RenderMarkdownContent(CurrentComponent);
				}
			}
		}

		public static readonly DirectProperty<MainWindow, bool> SpoilerFreeModeProperty =
			AvaloniaProperty.RegisterDirect<MainWindow, bool>(
				nameof(SpoilerFreeMode),
				o => o._spoilerFreeMode,
				(o, v) => o.SpoilerFreeMode = v
			);
		public static readonly DirectProperty<MainWindow, bool?> RootSelectionStateProperty =
			AvaloniaProperty.RegisterDirect<MainWindow, bool?>(
				nameof(RootSelectionState),
				o => o._rootSelectionState,
				(o, v) => o.RootSelectionState = v
			);
		public MainWindow()
		{
			try
			{
				InitializeComponent();
				DataContext = this;
				InitializeControls();
				InitializeTopMenu();
				UpdateMenuVisibility();
				InitializeDirectoryPickers();
				InitializeModListBox();

				Logger.Initialize();

				LoadSettings();

				_ = new InstallationService();

				_modManagementService = new ModManagementService(MainConfigInstance);
				_modManagementService.ModOperationCompleted += OnModOperationCompleted;
				_modManagementService.ModValidationCompleted += OnModValidationCompleted;

				_downloadCacheService = new DownloadCacheService();
				_downloadCacheService.SetDownloadManager();

				_modListService = new ModListService(MainConfigInstance);
				_validationService = new ValidationService(MainConfigInstance);
				_uiStateService = new UIStateService(MainConfigInstance, _validationService);
				_instructionManagementService = new InstructionManagementService();
				_selectionService = new SelectionService(MainConfigInstance);
				_fileSystemService = new FileSystemService();
				_guiPathService = new GuiPathService(MainConfigInstance, _fileSystemService);
				_dialogService = new DialogService(this);
				_menuBuilderService = new MenuBuilderService(_modManagementService, this);
				_dragDropService = new DragDropService(this, () => MainConfig.AllComponents, () => ProcessComponentsAsync(MainConfig.AllComponents));
				_fileLoadingService = new KOTORModSync.Services.FileLoadingService(MainConfigInstance, this);
				_componentEditorService = new Services.ComponentEditorService(MainConfigInstance, this);
				_componentSelectionService = new ComponentSelectionService(MainConfigInstance);
				_downloadOrchestrationService = new DownloadOrchestrationService(_downloadCacheService, MainConfigInstance, this);
				_downloadOrchestrationService.DownloadStateChanged += OnDownloadStateChanged;
				_filterUIService = new FilterUIService(MainConfigInstance);
				_markdownRenderingService = new MarkdownRenderingService();

				InitializeDownloadAnimationTimer();
				_instructionBrowsingService = new InstructionBrowsingService(MainConfigInstance, _dialogService);
				_instructionGenerationService = new InstructionGenerationService(MainConfigInstance, this, _downloadOrchestrationService);
				_validationDisplayService = new ValidationDisplayService(_validationService, () => MainConfig.AllComponents);
				_settingsService = new SettingsService(MainConfigInstance, this);
				_stepNavigationService = new StepNavigationService(MainConfigInstance, _validationService);

				_telemetryService = Core.Services.TelemetryService.Instance;

				CallbackObjects.SetCallbackObjects(
					new ConfirmationDialogCallback(this),
					new OptionsDialogCallback(this),
					new InformationDialogCallback(this)
				);
				PropertyChanged += SearchText_PropertyChanged;

				if ( Utility.GetOperatingSystem() == OSPlatform.Windows )
				{
					ConsoleConfig.DisableQuickEdit();
					ConsoleConfig.DisableConsoleCloseButton();
				}
				AddHandler(DragDrop.DropEvent, Drop);
				AddHandler(DragDrop.DragOverEvent, DragOver);

				InitializeModDirectoryWatcher();

				BuildGlobalActionsMenu();

				Opened += async (s, e) => await InitializeTelemetryIfEnabled();
			}
			catch ( Exception e )
			{
				Logger.LogException(e, customMessage: "A fatal error has occurred loading the main window");
				_telemetryService?.RecordError("MainWindow.Constructor", e.Message, e.StackTrace);
				throw;
			}
		}

		private async Task InitializeTelemetryIfEnabled()
		{
			try
			{
				var config = Core.Services.TelemetryConfiguration.Load();

				if ( config.IsEnabled )
				{
					_telemetryService.Initialize();
					Logger.LogVerbose("[Telemetry] Telemetry initialized from configuration");
				}
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "[Telemetry] Error initializing telemetry");
			}
			await Task.CompletedTask;
		}
		private static void UpdatePathDisplays(TextBlock modPathDisplay, TextBlock kotorPathDisplay)
		{
			if ( modPathDisplay != null )
				modPathDisplay.Text = MainConfig.SourcePath?.FullName ?? "Not set";
			if ( kotorPathDisplay != null )
				kotorPathDisplay.Text = MainConfig.DestinationPath?.FullName ?? "Not set";

		}
		private void UpdatePathDisplays()
		{
			TextBlock modPathDisplay = this.FindControl<TextBlock>(name: "CurrentModPathDisplay");
			TextBlock kotorPathDisplay = this.FindControl<TextBlock>(name: "CurrentKotorPathDisplay");
			UpdatePathDisplays(modPathDisplay, kotorPathDisplay);

			RefreshAllTooltips();
		}

		private void LoadSettings()
		{
			try
			{
				AppSettings settings = SettingsManager.LoadSettings();
				settings.ApplyToMainConfig(MainConfigInstance, out string theme);

				EditorMode = false;

				if ( !string.IsNullOrEmpty(theme) )
				{
					ApplyTheme(theme);

					ThemeManager.ApplyCurrentToWindow(this);
				}

				UpdatePathDisplays();

				UpdateDirectoryPickersFromSettings(settings);
				Logger.LogVerbose("Settings loaded and applied successfully");
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, customMessage: "Failed to load settings");
			}
		}

		private void UpdateDirectoryPickersFromSettings(AppSettings settings)
		{
			try
			{

				if ( !string.IsNullOrEmpty(settings.SourcePath) )
				{
					DirectoryPickerControl modPicker = this.FindControl<DirectoryPickerControl>("ModDirectoryPicker");
					DirectoryPickerControl step1ModPicker = GettingStartedTabControl?.FindControl<DirectoryPickerControl>("Step1ModDirectoryPicker");
					UpdateDirectoryPickerWithPath(modPicker, settings.SourcePath);
					UpdateDirectoryPickerWithPath(step1ModPicker, settings.SourcePath);
				}

				if ( !string.IsNullOrEmpty(settings.DestinationPath) )
				{
					DirectoryPickerControl kotorPicker = this.FindControl<DirectoryPickerControl>("KotorDirectoryPicker");
					DirectoryPickerControl step1KotorPicker = GettingStartedTabControl?.FindControl<DirectoryPickerControl>("Step1KotorDirectoryPicker");
					UpdateDirectoryPickerWithPath(kotorPicker, settings.DestinationPath);
					UpdateDirectoryPickerWithPath(step1KotorPicker, settings.DestinationPath);
				}
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Failed to update directory pickers from settings");
			}
		}

		private static void UpdateDirectoryPickerWithPath(DirectoryPickerControl picker, string path)
		{
			if ( picker == null || string.IsNullOrEmpty(path) )
				return;
			try
			{

				picker.SetCurrentPath(path);

				ComboBox comboBox = picker.FindControl<ComboBox>("PathSuggestions");
				if ( comboBox != null )
				{

					List<string> currentItems = (comboBox.ItemsSource as IEnumerable<string>)?.ToList() ?? new List<string>();
					if ( !currentItems.Contains(path) )
					{
						currentItems.Insert(0, path);

						if ( currentItems.Count > 20 )
							currentItems = currentItems.Take(20).ToList();
						comboBox.ItemsSource = currentItems;
					}

					comboBox.SelectedItem = path;
				}
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, $"Failed to update directory picker with path: {path}");
			}
		}

		private void SaveSettings()
		{
			try
			{
				string currentTheme = ThemeManager.GetCurrentStylePath();
				var settings = AppSettings.FromCurrentState(MainConfigInstance, currentTheme);
				SettingsManager.SaveSettings(settings);
				Logger.LogVerbose("Settings saved successfully");
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, customMessage: "Failed to save settings");
			}
		}

		[UsedImplicitly]
		private void ModPathInput_LostFocus(object sender, RoutedEventArgs e)
		{
			if ( sender is TextBox tb )
			{
				if ( _suppressPathEvents ) return;
				bool applied = TryApplySourcePath(tb.Text);
				if ( applied )
				{
					UpdatePathDisplays();
					UpdateStepProgress();
				}
				UpdatePathSuggestions(tb, this.FindControl<ComboBox>(name: "ModPathSuggestions"), ref _modSuggestCts);
			}
		}

		[UsedImplicitly]
		private void InstallPathInput_LostFocus(object sender, RoutedEventArgs e)
		{
			if ( sender is TextBox tb )
			{
				if ( _suppressPathEvents ) return;
				bool applied = TryApplyInstallPath(tb.Text);
				if ( applied )
				{
					UpdatePathDisplays();
					UpdateStepProgress();
				}
				UpdatePathSuggestions(tb, this.FindControl<ComboBox>(name: "InstallPathSuggestions"), ref _installSuggestCts);
			}
		}

		[UsedImplicitly]
		private void ModPathSuggestions_SelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			if ( _suppressComboEvents ) return;
			if ( sender is ComboBox comboBox && comboBox.SelectedItem is string path )
			{
				_suppressPathEvents = true;
				_suppressComboEvents = true;
				TextBox modInput = this.FindControl<TextBox>(name: "ModPathInput");
				if ( modInput != null )
				{
					modInput.Text = path;
					if ( TryApplySourcePath(path) )
					{
						UpdatePathDisplays();
						UpdateStepProgress();
					}

				}
				_suppressPathEvents = false;
				_suppressComboEvents = false;
			}
		}

		[UsedImplicitly]
		private void InstallPathSuggestions_SelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			if ( _suppressComboEvents )
				return;
			if ( !(sender is ComboBox comboBox) || !(comboBox.SelectedItem is string path) )
				return;
			_suppressPathEvents = true;
			_suppressComboEvents = true;
			TextBox installInput = this.FindControl<TextBox>(name: "InstallPathInput");
			if ( installInput != null )
			{
				installInput.Text = path;
				if ( TryApplyInstallPath(path) )
				{
					UpdatePathDisplays();
					UpdateStepProgress();
				}

			}
			_suppressPathEvents = false;
			_suppressComboEvents = false;
		}

		private bool TryApplySourcePath(string text)
		{

			bool result = _guiPathService.TryApplySourcePath(text, null);
			if ( result )
			{
				_ = GuiPathService.AddToRecentModsAsync(text);
			}
			return result;
		}

		private bool TryApplyInstallPath(string text)
		{
			return _guiPathService.TryApplyDestinationPath(text);
		}

		private static void UpdatePathSuggestions(TextBox input, ComboBox combo, ref CancellationTokenSource cts)
		{
			GuiPathService.UpdatePathSuggestions(input, combo, ref cts);
		}

		[UsedImplicitly]
		private void OnPathInputKeyDown(object sender, KeyEventArgs e)
		{
			try
			{
				if ( e.Key != Key.Enter ) return;
				if ( !(sender is TextBox tb) ) return;
				if ( _suppressPathEvents ) return;
				string name = tb.Name ?? string.Empty;
				bool pathSet = false;
				if ( name == "ModPathInput" )
					pathSet = TryApplySourcePath(tb.Text);
				else if ( name == "InstallPathInput" )
					pathSet = TryApplyInstallPath(tb.Text);
				if ( pathSet )
					UpdateStepProgress();
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}

		private async void AddToRecentMods(string path)
		{
			await GuiPathService.AddToRecentModsAsync(path);
			UpdatePathDisplays();
		}

		[UsedImplicitly]
		private async void BrowseModDir_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				string[] result = await _dialogService.ShowFileDialogAsync(isFolderDialog: true, windowName: "Select your mod directory");
				if ( !(result?.Length > 0) )
					return;
				TextBox modInput = this.FindControl<TextBox>(name: "ModPathInput");
				if ( modInput == null )
					return;
				modInput.Text = result[0];
				if ( !TryApplySourcePath(result[0]) )
					return;
				UpdatePathDisplays();
				UpdateStepProgress();

				ComboBox modCombo = this.FindControl<ComboBox>(name: "ModPathSuggestions");
				if ( modCombo != null )
					UpdatePathSuggestions(modInput, modCombo, ref _modSuggestCts);
			}
			catch ( Exception exc )
			{
				await Logger.LogExceptionAsync(exc);
			}
		}

		public static List<ModComponent> ComponentsList => MainConfig.AllComponents;

		public static List<string> TierOptions => CategoryTierDefinitions.TierDefinitions.Keys.ToList();
		[CanBeNull]
		public string SearchText
		{
			get => _searchText;
			set
			{
				if ( _searchText == value )
					return;
				_searchText = value;
				PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(SearchText)));
			}
		}

		public MainConfig MainConfigInstance = new MainConfig();

		[CanBeNull]
		public ModComponent CurrentComponent
		{
			get => MainConfig.CurrentComponent;
			set
			{

				if ( MainConfig.CurrentComponent != null )
				{
					MainConfig.CurrentComponent.PropertyChanged -= OnCurrentComponentPropertyChanged;
				}
				MainConfig.CurrentComponent = value;
				this.RaisePropertyChanged(CurrentComponentProperty, default, value);

				if ( MainConfig.CurrentComponent != null )
				{
					MainConfig.CurrentComponent.PropertyChanged += OnCurrentComponentPropertyChanged;
				}
			}
		}

		private bool IgnoreInternalTabChange { get; set; }

		private void OnCurrentComponentPropertyChanged(object sender, PropertyChangedEventArgs e)
		{
			if ( sender is ModComponent component && component == MainConfig.CurrentComponent )
			{

				RefreshComponentValidationState(component);
				RenderMarkdownContent(component);
			}
		}

		private void InitializeTopMenu()
		{
			var menu = new Menu();
			var fileMenu = new MenuItem { Header = "File" };

			var saveMenuItem = new MenuItem
			{
				Header = "Save",
				IsVisible = EditorMode,
				ItemsSource = new List<MenuItem>
			{
				new MenuItem
				{
					Header = "TOML",
					Command = ReactiveCommand.Create( () => SaveModFileAs_Click(new object(), new RoutedEventArgs(), "toml") ),
				},
				new MenuItem
				{
					Header = "YAML",
					Command = ReactiveCommand.Create( () => SaveModFileAs_Click(new object(), new RoutedEventArgs(), "yaml") ),
				},
				new MenuItem
				{
					Header = "Markdown",
					Command = ReactiveCommand.Create( () => SaveModFileAs_Click(new object(), new RoutedEventArgs(), "md") ),
				},
			}
			};

			var fileItems = new List<MenuItem>
		{
			new MenuItem
			{
				Header = "Open File",
				Command = ReactiveCommand.Create( () => LoadFile_Click(new object(), new RoutedEventArgs()) ),
			},
			new MenuItem
			{
				Header = "Close",
				Command = ReactiveCommand.Create( () => CloseTOMLFile_Click(new object(), new RoutedEventArgs()) ),
				IsVisible = EditorMode,
			},
			saveMenuItem,
			new MenuItem
			{
				Header = "Exit",
				Command = ReactiveCommand.Create( () => CloseButton_Click(new object(), new RoutedEventArgs()) ),
			},
		};
			fileMenu.ItemsSource = fileItems;

			var toolsMenu = new MenuItem { Header = "Tools" };
			var toolItems = new List<MenuItem>
			{
				new MenuItem
				{
					Header = "Fix iOS case sensitivity.",
					Command = ReactiveCommand.Create( () => FixIosCaseSensitivityClick(new object(), new RoutedEventArgs()) ),
				},
				new MenuItem
				{
					Header = "Fix file/folder permissions.",
					Command = ReactiveCommand.Create( () => FixPathPermissionsClick(new object(), new RoutedEventArgs()) ),
				},
				new MenuItem
				{
					Header = "Manage Checkpoints",
					Command = ReactiveCommand.Create( () => OpenCheckpointManagement_Click(new object(), new RoutedEventArgs()) ),
				},
				new MenuItem
				{
					Header = "Settings",
					Command = ReactiveCommand.Create( () => OpenSettings_Click(new object(), new RoutedEventArgs()) ),
				},
				new MenuItem
				{
					Header = "Open Output Window",
					Command = ReactiveCommand.Create( () => OpenOutputWindow_Click(new object(), new RoutedEventArgs()) ),
				},
			};
			ToolTip.SetTip(
				toolItems[0],
				value:
				"Create documentation for all instructions in the loaded setup. Useful if you need human-readable documentation of your TOML."
			);
			ToolTip.SetTip(
				toolItems[1],
				value:
				"Lowercase all files/folders recursively at the given path. Necessary for iOS installs."
			);
			ToolTip.SetTip(
				toolItems[2],
				value:
				"Fixes various file/folder permissions. On Unix, this will also find case-insensitive duplicate file/folder names."
			);
			if ( Utility.GetOperatingSystem() != OSPlatform.Windows )
			{
				var filePermFixTool = new MenuItem
				{
					Header = "Fix file and folder permissions",
					Command = ReactiveCommand.Create(() => ResolveDuplicateFilesAndFolders(new object(), new RoutedEventArgs())),
				};
				ToolTip.SetTip(
					filePermFixTool,
					"(Linux/Mac only) This will acquire a list of any case-insensitive duplicates in the mod directory or"
					+ " the kotor directory, including subfolders, and resolve them."
				);
				toolItems.Add(filePermFixTool);
			}
			toolsMenu.ItemsSource = toolItems;

			var helpMenu = new MenuItem { Header = "Help" };
			var deadlystreamMenu = new MenuItem
			{
				Header = "DeadlyStream",
				ItemsSource = new[]
				{
					new MenuItem
					{
						Header = "Discord",
						Command = ReactiveCommand.Create(() => UrlUtilities.OpenUrl("https://discord.gg/nDkHXfc36s")),
					},
					new MenuItem
					{
						Header = "Website",
						Command = ReactiveCommand.Create(() => UrlUtilities.OpenUrl("https://deadlystream.com")),
					},
				},
			};
			var neocitiesMenu = new MenuItem
			{
				Header = "KOTOR Community Portal",
				ItemsSource = new[]
				{
					new MenuItem
					{
						Header = "Discord",
						Command = ReactiveCommand.Create(() => UrlUtilities.OpenUrl("https://discord.com/invite/kotor")),
					},
					new MenuItem
					{
						Header = "Website",
						Command = ReactiveCommand.Create(() => UrlUtilities.OpenUrl("https://kotor.neocities.org")),
					},
				},
			};
			var pcgamingwikiMenu = new MenuItem
			{
				Header = "PCGamingWiki",
				ItemsSource = new[]
				{
					new MenuItem
					{
						Header = "KOTOR 1",
						Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl( "https://www.pcgamingwiki.com/wiki/Star_Wars:_Knights_of_the_Old_Republic" ) ),
					},
					new MenuItem
					{
						Header = "KOTOR 2: TSL",
						Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl( "https://www.pcgamingwiki.com/wiki/Star_Wars:_Knights_of_the_Old_Republic_II_-_The_Sith_Lords" ) ),
					},
				},
			};
			helpMenu.ItemsSource = new[] { deadlystreamMenu, neocitiesMenu, pcgamingwikiMenu };

			var engineRewritesMenu = new MenuItem
			{
				Header = "Open-Source Odyssey/Aurora Engines",
				ItemsSource = new[]
				{
					new MenuItem
					{
						Header = "KotOR.js",
						Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/KobaltBlu/KotOR.js") ),
					},
					new MenuItem
					{
						Header = "NorthernLights",
						Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/lachjames/NorthernLights") ),
					},
					new MenuItem
					{
						Header = "reone",
						Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/seedhartha/reone") ),
					},
				},
			};
			var otherProjectsMenu = new MenuItem
			{
				Header = "Other Projects",
				ItemsSource = new[]
				{
					new MenuItem
					{
						Header = "PyKotor Library",
						Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/NickHugi/PyKotor") ),
						ItemsSource = new []
						{
							new MenuItem
							{
								Header = "HoloPatcher",
								ItemsSource = new []
								{
									new MenuItem
									{
										Header = "DeadlyStream",
										Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://deadlystream.com/files/file/2243-holopatcher") ),
									},
									new MenuItem
									{
										Header = "GitHub",
										Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/NickHugi/PyKotor") ),
									},
								},
							},
							new MenuItem
							{
								Header = "Holocron Toolset",
								ItemsSource = new []
								{
									new MenuItem
									{
										Header = "GitHub",
										Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/NickHugi/PyKotor/blob/master/Tools/HolocronToolset") ),
									},
									new MenuItem
									{
										Header = "DeadlyStream",
										Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://deadlystream.com/files/file/1982-holocron-toolset") ),
									},
									new MenuItem
									{
										Header = "Discord",
										Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://discord.gg/hfAqtkVEzQ") ),
									},
								},
							},
							new MenuItem
							{
								Header = "Auto-Translate / Font Creator",
								Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://deadlystream.com/files/file/2375-kotor-autotranslate-tool") ),
							},
							new MenuItem
							{
								Header = "KotorDiff",
								Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://deadlystream.com/files/file/2364-kotordiff") ),
							},
						},
					},
					new MenuItem
					{
						Header = "LIP Composer / reone toolkit",
						ItemsSource = new []
						{
							new MenuItem
							{
								Header = "DeadlyStream",
								Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://deadlystream.com/files/file/1862-reone-toolkit") ),
							},
							new MenuItem
							{
								Header = "GitHub",
								Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/seedhartha/reone/wiki/Tooling") ),
							},
						},
					},
					engineRewritesMenu,
				},
			};
			var aboutMenu = new MenuItem
			{
				Header = "About",
				ItemsSource = new[]
				{
					new MenuItem
					{
						Header = "The ModSync Project",
						ItemsSource = new []
						{
							new MenuItem
							{
								Header = "DeadlyStream",
								Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://deadlystream.com/files/file/2317-kotormodsync/") ),
							},
							new MenuItem
							{
								Header = "GitHub",
								Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/th3w1zard1/KOTORModSync") ),
							},
						},
					},
					new MenuItem
					{
						Header = "HoloPatcher",
						ItemsSource = new []
						{
							new MenuItem
							{
								Header = "DeadlyStream",
								Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://deadlystream.com/files/file/2243-holopatcher") ),
							},
							new MenuItem
							{
								Header = "GitHub",
								Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl("https://github.com/NickHugi/PyKotor") ),
							},
						},
					},
				},
			};
			var moreMenu = new MenuItem
			{
				Header = "More",
				ItemsSource = new[]
				{
					otherProjectsMenu,
					new MenuItem
					{
						Header = "Modding Tools",
						Command = ReactiveCommand.Create( () => UrlUtilities.OpenUrl(url: "https://deadlystream.github.io/ds-kotor-modding-wiki/en/#!pages/tools_overview.md") ),
					},
				},
			};
			menu.ItemsSource = new[] { fileMenu, toolsMenu, helpMenu, aboutMenu, moreMenu };
			Menu topMenu = this.FindControl<Menu>(name: "TopMenu");
			if ( topMenu is null )
				return;
			topMenu.ItemsSource = menu.Items;
		}

		private void UpdateMenuVisibility()
		{
			Menu topMenu = this.FindControl<Menu>(name: "TopMenu");
			if ( topMenu is null )
				return;

			if ( topMenu.Items[0] is MenuItem fileMenu && fileMenu.Items is IList fileItems )
			{

				if ( fileItems.Count > 1 && fileItems[1] is MenuItem closeItem )
					closeItem.IsVisible = EditorMode;

				if ( fileItems.Count > 2 && fileItems[2] is MenuItem saveItem )
					saveItem.IsVisible = EditorMode;
			}

			if ( topMenu.Items[1] is MenuItem toolsMenu && toolsMenu.Items is IList toolItems )
			{

				if ( toolItems.Count > 0 && toolItems[0] is MenuItem docsItem )
					docsItem.IsVisible = EditorMode;
			}
		}

		private void RefreshSingleComponentVisuals(ModComponent component)
		{
			ModListService.RefreshSingleComponentVisuals(ModListBox, component);
		}

		private void RefreshModListItems()
		{
			try
			{
				_modListService.RefreshModListItems(ModListBox, EditorMode, BuildContextMenuForComponent);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}

		private static void DragOver(object sender, DragEventArgs e)
		{
			e.DragEffects = e.Data.Contains(DataFormats.Files)
				? DragDropEffects.Copy
				: DragDropEffects.None;
			e.Handled = true;
		}

		private async void Drop(object sender, DragEventArgs e)
		{
			try
			{
				if ( !e.Data.Contains(DataFormats.Files) )
				{
					Logger.LogVerbose("No files dropped");
					return;
				}

				if ( !(e.Data.Get(DataFormats.Files) is IEnumerable<IStorageItem> items) )
				{
					Logger.LogVerbose("Dropped items were not IStorageItem enumerable");
					return;
				}

				IStorageItem storageItem = items.FirstOrDefault();
				string filePath = storageItem?.TryGetLocalPath();
				if ( string.IsNullOrEmpty(filePath) )
				{
					Logger.LogVerbose("Dropped item had no path");
					return;
				}
				string fileExt = Path.GetExtension(filePath);
				switch ( storageItem )
				{

					case IStorageFile _ when fileExt.Equals(value: ".toml", StringComparison.OrdinalIgnoreCase)
											 || fileExt.Equals(value: ".tml", StringComparison.OrdinalIgnoreCase):
						{

							_ = await LoadTomlFile(filePath, fileType: "TOML file");
							break;
						}
					case IStorageFile _:
						(IArchive archive, FileStream archiveStream) = ArchiveHelper.OpenArchive(filePath);
						if ( archive is null || archiveStream is null )
						{
							Logger.LogVerbose("Dropped item was not an archive");
							return;
						}
						string exePath = ArchiveHelper.AnalyzeArchiveForExe(archiveStream, archive);
						await Logger.LogVerboseAsync(exePath);
						break;
					case IStorageFolder _:

						Logger.LogVerbose("Dropped item was a folder, not supported");
						break;
					default:
						Logger.LogVerbose("Dropped item was not a valid file or folder");
						throw new NullReferenceException(filePath);
				}
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		protected override void OnClosing(WindowClosingEventArgs e)
		{
			base.OnClosing(e);
			if ( IsClosingMainWindow )
				return;

			e.Cancel = true;

			HandleClosingAsync();
		}

		private async void HandleClosingAsync()
		{
			try
			{

				bool? result = (
					EditorMode is true
						? await ConfirmationDialog.ShowConfirmationDialogAsync(this, confirmText: "Really close KOTORModSync Please save your changes before pressing Quit?",
					noButtonText: "Cancel",
					yesButtonText: "Quit"
				)
					: true
				);
				if ( result != true )
					return;

				SaveSettings();

				_telemetryService?.Flush();
				_telemetryService?.Dispose();

				_fileSystemService?.Dispose();

				IsClosingMainWindow = true;
				await Dispatcher.UIThread.InvokeAsync(Close);
			}
			catch ( Exception e )
			{
				await Logger.LogExceptionAsync(e);
			}
		}
		public new event EventHandler<PropertyChangedEventArgs> PropertyChanged;
		public void InitializeControls()
		{
			if ( MainGrid.ColumnDefinitions == null || MainGrid.ColumnDefinitions.Count != 2 )
				throw new NullReferenceException(message: "MainGrid incorrectly defined, expected 3 columns.");

			Title = $"KOTORModSync v{MainConfig.CurrentVersion}";
			TitleTextBlock.Text = Title;
			ColumnDefinition componentListColumn = MainGrid.ColumnDefinitions[0]
												   ?? throw new NullReferenceException(message: "Column 0 of MainGrid (component list column) not defined.");

			componentListColumn.Width = new GridLength(300);

			RawTabControl.GetRawEditTextBox().LostFocus += RawEditTextBox_LostFocus;
			RawTabControl.GetRawEditTextBox().DataContext = new ObservableCollection<string>();
			EditorTabControl.CurrentComponent = CurrentComponent;

			UpdateStepProgress();
			_ = Logger.LogVerboseAsync("Setting up window move event handlers...");

			PointerPressed += InputElement_OnPointerPressed;
			PointerMoved += InputElement_OnPointerMoved;
			PointerReleased += InputElement_OnPointerReleased;
			PointerExited += InputElement_OnPointerReleased;
			FindComboBoxesInWindow(this);
		}
		private void SearchText_PropertyChanged([NotNull] object sender, [NotNull] PropertyChangedEventArgs e)
		{
			try
			{
				if ( e.PropertyName != nameof(SearchText) )
					return;

				if ( !string.IsNullOrWhiteSpace(SearchText) )
					FilterModList(SearchText);
				else

					RefreshModList();
			}
			catch ( Exception exception )
			{
				Logger.LogException(exception);
			}
		}
		private void InitializeModListBox()
		{
			try
			{
				if ( ModListBox == null )
					return;

				ModListBox.SelectionChanged += ModListBox_SelectionChanged;

				SetupDragAndDrop();

				if ( this.FindControl<CheckBox>("SelectAllCheckBox") is CheckBox selectAllCheckBox )
					selectAllCheckBox.IsCheckedChanged += SelectAllCheckBox_IsCheckedChanged;

				SetupKeyboardShortcuts();
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		private void SetupKeyboardShortcuts()
		{
			if ( ModListBox == null )
				return;
			ModListBox.KeyDown += (sender, e) =>
			{
				try
				{
					if ( !EditorMode )
						return;
					if ( !(ModListBox.SelectedItem is ModComponent component) )
						return;
					switch ( e.Key )
					{

						case Key.Up when e.KeyModifiers == KeyModifiers.Control:
							MoveComponentListItem(component, -1);
							e.Handled = true;
							break;

						case Key.Down when e.KeyModifiers == KeyModifiers.Control:
							MoveComponentListItem(component, 1);
							e.Handled = true;
							break;

						case Key.Delete:
							SetCurrentModComponent(component);
							_ = DeleteModWithConfirmationAsync(component);
							e.Handled = true;
							break;

						case Key.Space:
							component.IsSelected = !component.IsSelected;
							UpdateModCounts();
							e.Handled = true;
							break;
					}
				}
				catch ( Exception ex )
				{
					Logger.LogException(ex);
				}
			};
		}
		private async Task DeleteModWithConfirmationAsync(ModComponent component)
		{
			try
			{
				if ( component is null )
				{
					Logger.Log(message: "No component provided for deletion.");
					return;
				}
				bool? confirm = await ConfirmationDialog.ShowConfirmationDialogAsync(
					this,
					$"Are you sure you want to delete the mod '{component.Name}'? This action cannot be undone.",
					yesButtonText: "Delete",
					noButtonText: "Cancel"
				);
				if ( confirm == true )
				{
					SetCurrentModComponent(component);
					RemoveComponentButton_Click(null, null);
				}
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		public ContextMenu BuildContextMenuForComponent(ModComponent component)
		{
			var contextMenu = new ContextMenu();
			if ( component == null )
				return contextMenu;

			_ = contextMenu.Items.Add(new MenuItem
			{
				Header = component.IsSelected ? "â˜‘ï¸ Deselect Mod" : "â˜ Select Mod",
				Command = ReactiveCommand.Create(() =>
				{
					component.IsSelected = !component.IsSelected;
					UpdateModCounts();
					if ( component.IsSelected )
						ComponentCheckboxChecked(component, new HashSet<ModComponent>());
					else
						ComponentCheckboxUnchecked(component, new HashSet<ModComponent>());
				})
			});

			if ( EditorMode )
			{
				_ = contextMenu.Items.Add(new Separator());

				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "â¬†ï¸ Move Up",
					Command = ReactiveCommand.Create(() => MoveComponentListItem(component, -1)),
					InputGesture = new KeyGesture(Key.Up, KeyModifiers.Control)
				});
				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "â¬‡ï¸ Move Down",
					Command = ReactiveCommand.Create(() => MoveComponentListItem(component, 1)),
					InputGesture = new KeyGesture(Key.Down, KeyModifiers.Control)
				});
				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "ðŸ“Š Move to Top",
					Command = ReactiveCommand.Create(() => ModManagementService.MoveModToPosition(component, 0))
				});
				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "ðŸ“Š Move to Bottom",
					Command = ReactiveCommand.Create(() => ModManagementService.MoveModToPosition(component, MainConfig.AllComponents.Count - 1))
				});
				_ = contextMenu.Items.Add(new Separator());

				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "ðŸ—‘ï¸ Delete Mod",
					Command = ReactiveCommand.CreateFromTask(async () =>
					{
						SetCurrentModComponent(component);
						bool? confirm = await ConfirmationDialog.ShowConfirmationDialogAsync(
							this,
							$"Are you sure you want to delete the mod '{component.Name}'? This action cannot be undone.",
							yesButtonText: "Delete",
							noButtonText: "Cancel"
						);
						if ( confirm == true )
							RemoveComponentButton_Click(null, null);
					})
				});
				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "ðŸ”„ Duplicate Mod",
					Command = ReactiveCommand.Create(() =>
					{
						ModComponent duplicated = ModManagementService.DuplicateMod(component);
						if ( duplicated != null )
						{
							SetCurrentModComponent(duplicated);
							SetTabInternal(TabControl, GuiEditTabItem);
						}
					})
				});
				_ = contextMenu.Items.Add(new Separator());

				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "ðŸ“ Edit Instructions",
					Command = ReactiveCommand.Create(() =>
					{
						SetCurrentModComponent(component);
						SetTabInternal(TabControl, GuiEditTabItem);
					})
				});
				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "ðŸ“„ Edit Raw TOML",
					Command = ReactiveCommand.Create(() =>
					{
						SetCurrentModComponent(component);
						SetTabInternal(TabControl, RawEditTabItem);
					})
				});
				_ = contextMenu.Items.Add(new Separator());

				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "ðŸ§ª Test Install This Mod",
					Command = ReactiveCommand.Create(() =>
					{
						SetCurrentModComponent(component);
						InstallModSingle_Click(null, null);
					})
				});
				_ = contextMenu.Items.Add(new MenuItem
				{
					Header = "ðŸ” Validate Mod Files",
					Command = ReactiveCommand.Create(() =>
					{
						ModValidationResult validation = ModManagementService.ValidateMod(component);
						if ( !validation.IsValid )
						{
							_ = InformationDialog.ShowInformationDialogAsync(this,
								$"Validation failed for '{component.Name}':\n\n" +
								string.Join("\n", validation.Errors.Take(5)));
						}
						else
						{
							_ = InformationDialog.ShowInformationDialogAsync(this,
								$"âœ… '{component.Name}' validation passed!");
						}
					})
				});
			}
			return contextMenu;
		}

		private void BuildGlobalActionsMenu()
		{

			DropDownButton globalActionsButton = ModListSidebar?.GlobalActionsButton;
			if ( globalActionsButton?.Flyout is MenuFlyout globalActionsFlyout )
				BuildMenuFlyoutItems(globalActionsFlyout);

			ContextMenu modListContextMenu = ModListSidebar?.ModListContextMenu;
			if ( modListContextMenu != null )
				BuildContextMenuItems(modListContextMenu);
		}

		private void BuildMenuFlyoutItems(MenuFlyout menu)
		{
			menu.Items.Clear();

			_ = menu.Items.Add(new MenuItem
			{
				Header = "ðŸ”„ Refresh List",
				Command = ReactiveCommand.Create(() => RefreshComponents_Click(null, null)),
				InputGesture = new KeyGesture(Key.F5)
			});
			_ = menu.Items.Add(new MenuItem
			{
				Header = "ðŸ”„ Validate All Mods",
				Command = ReactiveCommand.Create(async () =>
				{
					Dictionary<ModComponent, ModValidationResult> results = ModManagementService.ValidateAllMods();
					int errorCount = results.Count(r => !r.Value.IsValid);
					int warningCount = results.Sum(r => r.Value.Warnings.Count);
					await InformationDialog.ShowInformationDialogAsync(this,
						"Validation complete!\n\n" +
						$"Errors: {errorCount}\n" +
						$"Warnings: {warningCount}\n\n" +
						$"Valid mods: {results.Count(r => r.Value.IsValid)}/{results.Count}");
				})
			});
			_ = menu.Items.Add(new Separator());
			if ( EditorMode )
			{

				_ = menu.Items.Add(new MenuItem
				{
					Header = "âž• Add New Mod",
					Command = ReactiveCommand.Create(() =>
					{
						ModComponent newMod = ModManagementService.CreateMod();
						if ( newMod != null )
						{
							SetCurrentModComponent(newMod);
							SetTabInternal(TabControl, GuiEditTabItem);
						}
					})
				});
				_ = menu.Items.Add(new Separator());

				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ”Ž Select by Name",
					Command = ReactiveCommand.Create(() => ModManagementService.SortMods())
				});
				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ”Ž Select by Category",
					Command = ReactiveCommand.Create(() => ModManagementService.SortMods(ModSortCriteria.Category))
				});
				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ”Ž Select by Tier",
					Command = ReactiveCommand.Create(() => ModManagementService.SortMods(ModSortCriteria.Tier))
				});
				_ = menu.Items.Add(new Separator());

				_ = menu.Items.Add(new MenuItem
				{
					Header = "âš™ï¸ Mod Management Tools",
					Command = ReactiveCommand.Create(async () => await ShowModManagementDialog())
				});
				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ“ˆ Mod Statistics",
					Command = ReactiveCommand.Create(async () =>
					{
						ModStatistics stats = ModManagementService.GetModStatistics();
						string statsText = "ðŸ“Š Mod Statistics\n\n" +
										   $"Total Mods: {stats.TotalMods}\n" +
										   $"Selected: {stats.SelectedMods}\n" +
										   $"Downloaded: {stats.DownloadedMods}\n\n" +
										   $"Categories:\n{string.Join("\n", stats.Categories.Select(c => $"  â€¢ {c.Key}: {c.Value}"))}\n\n" +
										   $"Tiers:\n{string.Join("\n", stats.Tiers.Select(t => $"  â€¢ {t.Key}: {t.Value}"))}\n\n" +
										   $"Average Instructions/Mod: {stats.AverageInstructionsPerMod:F1}\n" +
										   $"Average Options/Mod: {stats.AverageOptionsPerMod:F1}";
						await InformationDialog.ShowInformationDialogAsync(this, statsText);
					})
				});
				_ = menu.Items.Add(new Separator());

				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ’¾ Save Config",
					Command = ReactiveCommand.Create(() => SaveModFileAs_Click(null, null, "toml")),
					InputGesture = new KeyGesture(Key.S, KeyModifiers.Control)
				});
				_ = menu.Items.Add(new MenuItem
				{
					Header = "âŒ Close TOML",
					Command = ReactiveCommand.Create(() => CloseTOMLFile_Click(null, null))
				});
			}
		}

		private void BuildContextMenuItems(ContextMenu menu)
		{
			menu.Items.Clear();

			_ = menu.Items.Add(new MenuItem
			{
				Header = "ðŸ”„ Refresh List",
				Command = ReactiveCommand.Create(() => RefreshComponents_Click(null, null)),
				InputGesture = new KeyGesture(Key.F5)
			});
			_ = menu.Items.Add(new MenuItem
			{
				Header = "ðŸ”„ Validate All Mods",
				Command = ReactiveCommand.Create(async () =>
				{
					Dictionary<ModComponent, ModValidationResult> results = ModManagementService.ValidateAllMods();
					int errorCount = results.Count(r => !r.Value.IsValid);
					int warningCount = results.Sum(r => r.Value.Warnings.Count);
					await InformationDialog.ShowInformationDialogAsync(this,
						"Validation complete!\n\n" +
						$"Errors: {errorCount}\n" +
						$"Warnings: {warningCount}\n\n" +
						$"Valid mods: {results.Count(r => r.Value.IsValid)}/{results.Count}");
				})
			});
			_ = menu.Items.Add(new Separator());
			if ( EditorMode )
			{

				_ = menu.Items.Add(new MenuItem
				{
					Header = "âž• Add New Mod",
					Command = ReactiveCommand.Create(() =>
					{
						ModComponent newMod = ModManagementService.CreateMod();
						if ( newMod == null )
							return;
						SetCurrentModComponent(newMod);
						SetTabInternal(TabControl, GuiEditTabItem);
					})
				});
				_ = menu.Items.Add(new Separator());

				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ”Ž Select by Name",
					Command = ReactiveCommand.Create(() => ModManagementService.SortMods())
				});
				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ”Ž Select by Category",
					Command = ReactiveCommand.Create(() => ModManagementService.SortMods(ModSortCriteria.Category))
				});
				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ”Ž Select by Tier",
					Command = ReactiveCommand.Create(() => ModManagementService.SortMods(ModSortCriteria.Tier))
				});
				_ = menu.Items.Add(new Separator());

				_ = menu.Items.Add(new MenuItem
				{
					Header = "âš™ï¸ Mod Management Tools",
					Command = ReactiveCommand.Create(async () => await ShowModManagementDialog())
				});
				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ“ˆ Mod Statistics",
					Command = ReactiveCommand.Create(async () =>
					{
						ModStatistics stats = ModManagementService.GetModStatistics();
						string statsText = "ðŸ“Š Mod Statistics\n\n" +
										   $"Total Mods: {stats.TotalMods}\n" +
										   $"Selected: {stats.SelectedMods}\n" +
										   $"Downloaded: {stats.DownloadedMods}\n\n" +
										   $"Categories:\n{string.Join("\n", stats.Categories.Select(c => $"  â€¢ {c.Key}: {c.Value}"))}\n\n" +
										   $"Tiers:\n{string.Join("\n", stats.Tiers.Select(t => $"  â€¢ {t.Key}: {t.Value}"))}\n\n" +
										   $"Average Instructions/Mod: {stats.AverageInstructionsPerMod:F1}\n" +
										   $"Average Options/Mod: {stats.AverageOptionsPerMod:F1}";
						await InformationDialog.ShowInformationDialogAsync(this, statsText);
					})
				});
				_ = menu.Items.Add(new Separator());

				_ = menu.Items.Add(new MenuItem
				{
					Header = "ðŸ’¾ Save Config",
					Command = ReactiveCommand.Create(() => SaveModFileAs_Click(null, null, "toml")),
					InputGesture = new KeyGesture(Key.S, KeyModifiers.Control)
				});
				_ = menu.Items.Add(new MenuItem
				{
					Header = "âŒ Close TOML",
					Command = ReactiveCommand.Create(() => CloseTOMLFile_Click(null, null))
				});
			}
		}
		private void SetupDragAndDrop()
		{
			if ( ModListBox == null )
				return;

			ModListBox.PointerPressed += ModListBox_PointerPressed;
			ModListBox.AddHandler(DragDrop.DragOverEvent, ModListBox_DragOver);
			ModListBox.AddHandler(DragDrop.DropEvent, ModListBox_Drop);
		}
		private void ModListBox_PointerPressed(object sender, PointerPressedEventArgs e)
		{
			_dragDropService.HandlePointerPressed(e, ModListBox, EditorMode);
		}
		private void ModListBox_DragOver(object sender, DragEventArgs e)
		{
			_dragDropService.HandleDragOver(e, EditorMode, this);
		}
		private void ModListBox_Drop(object sender, DragEventArgs e)
		{
			_dragDropService.HandleDrop(e, EditorMode);
		}
		private async Task ShowModManagementDialog()
		{
			try
			{
				var dialogService = new ModManagementDialogService(this, ModManagementService,
					() => MainConfigInstance.allComponents.ToList(),
					(components) => MainConfigInstance.allComponents = components);
				var dialog = new ModManagementDialog(ModManagementService, dialogService);
				await dialog.ShowDialog(this);
				if ( dialog.ModificationsApplied )
				{
					await ProcessComponentsAsync(MainConfig.AllComponents);
					await Logger.LogVerboseAsync("Applied mod management changes");
				}
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		public void StartDragComponent(ModComponent component, PointerPressedEventArgs e)
		{
			_dragDropService.StartDragComponent(component, e, EditorMode);
		}
		private void ModListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			try
			{
				Logger.LogVerbose($"[ModListBox_SelectionChanged] START - SelectedItem type: {ModListBox.SelectedItem?.GetType().Name ?? "null"}");
				if ( ModListBox.SelectedItem is ModComponent component )
				{
					Logger.LogVerbose($"[ModListBox_SelectionChanged] ModComponent selected: '{component.Name}' (GUID={component.Guid})");
					Logger.LogVerbose($"[ModListBox_SelectionChanged] ModComponent has {component.Instructions.Count} instructions, {component.Options.Count} options");
					Logger.LogVerbose("[ModListBox_SelectionChanged] Calling SetCurrentComponent");
					SetCurrentModComponent(component);
					Logger.LogVerbose("[ModListBox_SelectionChanged] SetCurrentComponent completed");
				}
				else
				{
					Logger.LogVerbose("[ModListBox_SelectionChanged] SelectedItem is not a ModComponent");
				}
				Logger.LogVerbose("[ModListBox_SelectionChanged] COMPLETED");
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, customMessage: "[ModListBox_SelectionChanged] Exception occurred");
			}
		}
		private bool _suppressSelectAllCheckBoxEvents;
		private void SelectAllCheckBox_IsCheckedChanged(object sender, RoutedEventArgs e)
		{
			try
			{
				if ( !(sender is CheckBox checkBox) || _suppressSelectAllCheckBoxEvents )
					return;
				_componentSelectionService.HandleSelectAllCheckbox(checkBox.IsChecked, ComponentCheckboxChecked, ComponentCheckboxUnchecked);

				UpdateModCounts();
				UpdateStepProgress();

				ResetDownloadStatusDisplay();
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		private void FilterModList(string searchText)
		{
			try
			{
				if ( ModListBox == null )
					return;
				var searchOptions = new ModSearchOptions
				{
					SearchInName = true,
					SearchInAuthor = true,
					SearchInCategory = true,
					SearchInDescription = true
				};
				List<ModComponent> filteredComponents = ModManagementService.SearchMods(searchText, searchOptions);
				PopulateModList(filteredComponents);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		private void RefreshModList()
		{
			try
			{
				PopulateModList(MainConfig.AllComponents);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		private void RefreshModListVisuals()
		{
			try
			{
				ModListService.RefreshModListVisuals(ModListBox, UpdateStepProgress);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}

		private void RefreshAllTooltips()
		{
			try
			{
				if ( ModListBox == null ) return;

				var modListItems = ModListBox.GetVisualDescendants().OfType<Controls.ModListItem>();
				foreach ( var item in modListItems )
				{
					if ( item.DataContext is ModComponent component )
					{
						item.UpdateTooltip(component);
					}
				}
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Error refreshing tooltips");
			}
		}

		private void RefreshComponentValidationState(ModComponent component)
		{
			try
			{
				if ( ModListBox == null || component == null )
					return;

				Dispatcher.UIThread.Post(() =>
				{
					try
					{

						if ( !(ModListBox.ContainerFromItem(component) is ListBoxItem container) )
							return;

						ModListItem modListItem = container.GetVisualDescendants().OfType<ModListItem>().FirstOrDefault();
						if ( modListItem == null )
							return;

						modListItem.UpdateValidationState(component);
					}
					catch ( Exception ex )
					{
						Logger.LogException(ex, "Error refreshing component validation state on UI thread");
					}
				}, DispatcherPriority.Normal);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Error posting component validation refresh to UI thread");
			}
		}
		private void PopulateModList(List<ModComponent> components)
		{
			try
			{
				ModListService.PopulateModList(ModListBox, components, UpdateModCounts);

				if ( string.IsNullOrWhiteSpace(SearchText) && MainConfig.AllComponents.Count > 0 )
					InitializeFilterUi(MainConfig.AllComponents);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		public void UpdateModCounts()
		{
			try
			{
				_modListService.UpdateModCounts(
					ModListSidebar?.ModCountTextBlock,
					ModListSidebar?.SelectedCountTextBlock,
					this.FindControl<CheckBox>("SelectAllCheckBox"),
					suppress => _suppressSelectAllCheckBoxEvents = suppress
				);

				RefreshModListVisuals();
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		public static void FilterControlListItems([NotNull] object item, [NotNull] string searchText)
		{
			if ( searchText == null )
				throw new ArgumentNullException(nameof(searchText));
			if ( !(item is Control controlItem) )
				return;
			if ( controlItem.Tag is ModComponent thisComponent )
				ApplySearchVisibility(controlItem, thisComponent.Name, searchText);

			IEnumerable<ILogical> controlItemArray = controlItem.GetLogicalChildren();
			foreach ( TreeViewItem childItem in controlItemArray.OfType<TreeViewItem>() )
			{

				FilterControlListItems(childItem, searchText);
			}
		}
		private static void ApplySearchVisibility(
			[NotNull] Visual item,
			[NotNull] string itemName,
			[NotNull] string searchText
		)
		{
			if ( item is null )
				throw new ArgumentNullException(nameof(item));
			if ( itemName is null )
				throw new ArgumentNullException(nameof(itemName));
			if ( searchText is null )
				throw new ArgumentNullException(nameof(searchText));

			item.IsVisible = SearchUtilities.ShouldBeVisible(itemName, searchText);
		}
		private void FindProblemControls([CanBeNull] Control control)
		{
			if ( !(control is ILogical visual) )
				throw new ArgumentNullException(nameof(control));
			if ( control is ComboBox || control is MenuItem )
			{
				control.Tapped -= ComboBox_Opened;
				control.PointerCaptureLost -= ComboBox_Opened;
				control.Tapped += ComboBox_Opened;
				control.PointerCaptureLost += ComboBox_Opened;
			}
			if ( visual.LogicalChildren.IsNullOrEmptyOrAllNull() )
				return;

			foreach ( ILogical child in visual.LogicalChildren )
			{
				if ( child is Control childControl )
					FindProblemControls(childControl);
			}
		}

		public void FindComboBoxesInWindow([NotNull] Window thisWindow)
		{
			if ( thisWindow is null )
				throw new ArgumentNullException(nameof(thisWindow));
			FindProblemControls(thisWindow);
		}
		private void ComboBox_Opened([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			_mouseDownForWindowMoving = false;
			_ignoreWindowMoveWhenClickingComboBox = true;
		}
		private void InputElement_OnPointerMoved([NotNull] object sender, [NotNull] PointerEventArgs e)
		{
			if ( !_mouseDownForWindowMoving )
				return;
			if ( _ignoreWindowMoveWhenClickingComboBox )
			{
				_ignoreWindowMoveWhenClickingComboBox = false;
				_mouseDownForWindowMoving = false;
				return;
			}
			PointerPoint currentPoint = e.GetCurrentPoint(this);
			Position = new PixelPoint(
				Position.X + (int)(currentPoint.Position.X - _originalPoint.Position.X),
				Position.Y + (int)(currentPoint.Position.Y - _originalPoint.Position.Y)
			);
		}
		private void InputElement_OnPointerPressed([NotNull] object sender, [NotNull] PointerEventArgs e)
		{
			if ( WindowState == WindowState.Maximized || WindowState == WindowState.FullScreen )
				return;

			if ( ShouldIgnorePointerForWindowDrag(e) )
				return;
			_mouseDownForWindowMoving = true;
			_originalPoint = e.GetCurrentPoint(this);
		}
		private bool ShouldIgnorePointerForWindowDrag(PointerEventArgs e)
		{

			if ( !(e.Source is Visual source) )
				return false;

			Visual current = source;
			while ( current != null && current != this )
			{
				switch ( current )
				{

					case Button _:
					case TextBox _:
					case ComboBox _:
					case ListBox _:
					case MenuItem _:
					case Menu _:
					case Expander _:
					case Slider _:
					case TabControl _:
					case TabItem _:

					case Control control when control.ContextMenu?.IsOpen == true:
						return true;
					default:

						current = current.GetVisualParent();
						break;
				}
			}
			return false;
		}
		private void InputElement_OnPointerReleased([NotNull] object sender, [NotNull] PointerEventArgs e) =>
			_mouseDownForWindowMoving = false;
		[UsedImplicitly]
		private void CloseButton_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) =>
			Close();
		[UsedImplicitly]
		private void MinimizeButton_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) =>
			WindowState = WindowState.Minimized;
		[ItemCanBeNull]
		public async Task<string> SaveFileAsync(
			string saveFileName = null
		)
		{
			return await _dialogService.ShowSaveFileDialogAsync(saveFileName ?? "my_toml_instructions.toml", "toml");
		}

		[UsedImplicitly]
		private async void LoadFile_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			_telemetryService?.RecordUIInteraction("click", "LoadFileButton");

			try
			{
				var startTime = DateTime.UtcNow;

				string[] result = await _dialogService.ShowFileDialogAsync(
					windowName: "Load a TOML or Markdown instruction file",
					isFolderDialog: false
				);
				if ( result is null || result.Length <= 0 )
					return;
				string filePath = result[0];
				if ( !PathValidator.IsValidPath(filePath) )
					return;

				string fileExtension = Path.GetExtension(filePath)?.ToLowerInvariant();
				bool isTomlFile = fileExtension == ".toml" || fileExtension == ".tml";

				if ( isTomlFile )
				{
					bool loadedAsToml = false;
					try
					{
						await Logger.LogAsync($"Attempting to load file as TOML: {Path.GetFileName(filePath)}");
						loadedAsToml = await LoadTomlFile(filePath, fileType: "file");
					}
					catch ( Exception tomlEx )
					{

						await Logger.LogVerboseAsync($"File is not a valid TOML file: {tomlEx.Message}");
					}

					if ( loadedAsToml )
					{
						await Logger.LogAsync("File loaded successfully as TOML.");
						_telemetryService?.RecordEvent("file.loaded", new Dictionary<string, object>
						{
							["file_type"] = "toml",
							["duration_ms"] = (DateTime.UtcNow - startTime).TotalMilliseconds,
							["component_count"] = MainConfig.AllComponents.Count,
						});
						return;
					}
				}

				await Logger.LogAsync("Attempting to load file as Markdown...");
				await _fileLoadingService.LoadMarkdownFileAsync(
					filePath,
					EditorMode,
					() => ProcessComponentsAsync(MainConfig.AllComponents),
					TryAutoGenerateInstructionsForComponents,
					profile: null
				);

				_telemetryService?.RecordEvent("file.loaded", new Dictionary<string, object>
				{
					["file_type"] = "markdown",
					["duration_ms"] = (DateTime.UtcNow - startTime).TotalMilliseconds,
					["component_count"] = MainConfig.AllComponents.Count,
				});
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
				_telemetryService?.RecordError("file.load", ex.Message, ex.StackTrace);
			}
		}
		[UsedImplicitly]
		private void LoadInstallFile_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) => LoadFile_Click(sender, e);
		[UsedImplicitly]
		private void OpenLink_Click([NotNull] object sender, [NotNull] TappedEventArgs e)
		{
			if ( !(sender is TextBlock textBlock) )
				return;
			try
			{
				string url = textBlock.Text;
				if ( string.IsNullOrEmpty(url) )
					throw new InvalidOperationException(message: "url (textBlock.Text) cannot be null/empty");
				UrlUtilities.OpenUrl(url);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, $"Failed to open URL: {ex.Message}");
			}
		}
		[UsedImplicitly]
		private async void BrowseSourceFiles_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				var button = (Button)sender;
				Instruction thisInstruction = (Instruction)button.DataContext
											?? throw new NullReferenceException(message: "Could not find instruction instance");

				if ( button.Tag is TextBox sourceTextBox )
					await _instructionBrowsingService.BrowseSourceFilesAsync(thisInstruction, sourceTextBox);
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}
		private async void BrowseSourceFromFolders_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				var button = (Button)sender;
				Instruction thisInstruction = (Instruction)button.DataContext
											?? throw new NullReferenceException(message: "Could not find instruction instance");

				if ( button.Tag is TextBox sourceTextBox )
					await _instructionBrowsingService.BrowseSourceFoldersAsync(thisInstruction, sourceTextBox);
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private async void BrowseDestination_Click([CanBeNull] object sender, [CanBeNull] RoutedEventArgs e)
		{
			try
			{
				Button button = (Button)sender ?? throw new InvalidOperationException();
				Instruction thisInstruction = (Instruction)button.DataContext
											?? throw new NullReferenceException(message: "Could not find instruction instance");

				if ( button.Tag is TextBox destinationTextBox )
					await _instructionBrowsingService.BrowseDestinationAsync(thisInstruction, destinationTextBox);
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private async void RawTabApply_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					await InformationDialog.ShowInformationDialogAsync(
						this,
						message: "Please select a component from the list or create a new one before saving."
					);
					return;
				}
				await Logger.LogVerboseAsync($"Selected '{CurrentComponent.Name}'");
				if ( !await ShouldSaveChangesAsync() )
					return;
				await ProcessComponentsAsync(MainConfig.AllComponents);
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private async void FixPathPermissionsClick([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				string[] results = await _dialogService.ShowFileDialogAsync(
					windowName: "Select the folder(s) you'd like to fix permissions to.",
					isFolderDialog: true,
					allowMultiple: true
				);
				if ( results is null || results.Length <= 0 )
					return;
				foreach ( string folder in results )
				{
					DirectoryInfo thisDir = PathHelper.TryGetValidDirectoryInfo(folder);
					if ( thisDir is null || !thisDir.Exists )
					{
						_ = Logger.LogErrorAsync($"Directory not found: '{folder}', skipping...");
						continue;
					}
					await FilePermissionHelper.FixPermissionsAsync(thisDir);
					Logger.Log($"Completed FixPathPermissions at '{thisDir.FullName}'");
				}
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}

		[UsedImplicitly]
		private async void FixIosCaseSensitivityClick([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				string[] results = await _dialogService.ShowFileDialogAsync(
					windowName: "Select the folder(s) you'd like to lowercase all files/folders inside",
					isFolderDialog: true,
					allowMultiple: true
				);
				if ( results is null || results.Length <= 0 )
					return;
				int numObjectsRenamed = 0;
				foreach ( string folder in results )
				{
					var thisDir = new DirectoryInfo(folder);
					if ( !thisDir.Exists )
					{
						_ = Logger.LogErrorAsync($"Directory not found: '{thisDir.FullName}', skipping...");
						continue;
					}
					numObjectsRenamed += await UIUtilities.FixIOSCaseSensitivity(thisDir);
				}
				Logger.Log($"Successfully renamed {numObjectsRenamed} files/folders.");
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}

		private async void ResolveDuplicateFilesAndFolders([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				bool? answer = await ConfirmationDialog.ShowConfirmationDialogAsync(
					this,
					"This button will resolve all case-sensitive duplicate files/folders in your install directory and your mod download directory."
					+ Environment.NewLine
					+ " WARNING: This method may take a while and cannot be stopped until it finishes. Really continue?"
				);
				if ( answer != true )
					return;
				await Logger.LogAsync("Finding duplicate case-insensitive folders/files in the install destination...");
				string destPath = MainConfig.DestinationPath?.FullName;
				if ( string.IsNullOrEmpty(destPath) )
				{
					await Logger.LogErrorAsync("Destination path is null or empty, skipping duplicate file/folder search.");
					return;
				}
				IEnumerable<FileSystemInfo> duplicates = PathHelper.FindCaseInsensitiveDuplicates(destPath);
				var fileSystemInfos = duplicates.ToList();
				foreach ( FileSystemInfo duplicate in fileSystemInfos )
				{
					await Logger.LogWarningAsync(duplicate?.FullName + " is duplicated on the storage drive.");
				}
				answer = await ConfirmationDialog.ShowConfirmationDialogAsync(
					this,
					"Duplicate file/folder search finished."
					+ Environment.NewLine
					+ $" Found {fileSystemInfos.Count} files/folders that have duplicates in your install dir."
					+ Environment.NewLine
					+ " Delete all duplicates except the ones most recently modified?"
				);
				if ( answer != true )
					return;
				IEnumerable<IGrouping<string, FileSystemInfo>> groupedDuplicates = fileSystemInfos.GroupBy(fs => fs.Name.ToLowerInvariant());
				foreach ( IGrouping<string, FileSystemInfo> group in groupedDuplicates )
				{
					var orderedDuplicates = group.OrderByDescending(fs => fs.LastWriteTime).ToList();
					if ( orderedDuplicates.Count <= 1 )
						continue;
					for ( int i = 1; i < orderedDuplicates.Count; i++ )
					{
						try
						{
							switch ( orderedDuplicates[i] )
							{
								case FileInfo fileInfo:
									fileInfo.Delete();
									break;
								case DirectoryInfo directoryInfo:
									directoryInfo.Delete(recursive: true);
									break;
								default:
									Logger.Log(orderedDuplicates[i].FullName + " does not exist somehow?");
									continue;
							}
							await Logger.LogAsync($"Deleted {orderedDuplicates[i].FullName}");
						}
						catch ( Exception deletionException )
						{
							await Logger.LogExceptionAsync(
								deletionException,
								$"Failed to delete {orderedDuplicates[i].FullName}"
							);
						}
					}
				}
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}

		[UsedImplicitly]
		private void ValidateButton_Click([CanBeNull] object sender, [NotNull] RoutedEventArgs e)
		{
			_telemetryService?.RecordUIInteraction("click", "ValidateButton");

			Task.Run(async () =>
			{
				try
				{
					var startTime = DateTime.UtcNow;
					using ( var activity = _telemetryService?.StartActivity("validation.environment") )
					{

						(bool validationResult, _) = await InstallationService.ValidateInstallationEnvironmentAsync(
							MainConfigInstance,
							async message => await ConfirmationDialog.ShowConfirmationDialogAsync(this, message) == true
						);

						var modIssues = new List<ValidationIssue>();
						var systemIssues = new List<string>();
						if ( !validationResult )
						{

							await AnalyzeValidationFailures(modIssues, systemIssues);
						}

						await Dispatcher.UIThread.InvokeAsync(async () =>
						{

							_ = await ValidationDialog.ShowValidationDialog(
								this,
								validationResult,
								validationResult
									? "No issues found. Your mods are ready to install!"
									: "Some issues need to be resolved before installation can proceed.",
								modIssues.Count > 0 ? modIssues : null,
								systemIssues.Count > 0 ? systemIssues : null,
								() => OpenOutputWindow_Click(null, null)
							);

							if ( validationResult )
							{

								CheckBox step4Check = this.FindControl<CheckBox>(name: "Step4Checkbox");
								if ( step4Check != null ) step4Check.IsChecked = true;
								UpdateStepProgress();
							}
						});
					}
				}
				catch ( Exception ex )
				{
					await Logger.LogExceptionAsync(ex);
				}
			});
		}

		private async Task AnalyzeValidationFailures(List<ValidationIssue> modIssues, List<string> systemIssues)
		{
			await _validationService.AnalyzeValidationFailures(modIssues, systemIssues);
		}

		[UsedImplicitly]
		private async void AddComponentButton_Click([CanBeNull] object sender, [CanBeNull] RoutedEventArgs e)
		{
			try
			{

				ModComponent newComponent = _componentEditorService.CreateNewComponent();

				LoadComponentDetails(newComponent);

				await ProcessComponentsAsync(MainConfig.AllComponents);
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private async void RefreshComponents_Click([CanBeNull] object sender, [CanBeNull] RoutedEventArgs e)
		{
			try
			{
				await ProcessComponentsAsync(MainConfig.AllComponents);
			}
			catch ( Exception exc )
			{
				await Logger.LogExceptionAsync(exc);
			}
		}

		[UsedImplicitly]
		private async void CloseTOMLFile_Click([CanBeNull] object sender, [CanBeNull] RoutedEventArgs e)
		{
			try
			{
				await Logger.LogAsync(message: "Closing TOML configuration and clearing component list...");

				MainConfigInstance.allComponents = new List<ModComponent>();

				SetCurrentModComponent(c: null);

				SummaryTabItem.IsVisible = false;
				GuiEditTabItem.IsVisible = false;
				RawEditTabItem.IsVisible = false;

				SetTabInternal(TabControl, InitialTab);

				ModListBox?.Items.Clear();

				UpdateStepProgress();
				UpdateModCounts();
				await Logger.LogAsync(message: "TOML configuration closed successfully. ModComponent list cleared.");
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private async void RemoveComponentButton_Click([CanBeNull] object sender, [CanBeNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					Logger.Log(message: "No component loaded into editor - nothing to remove.");
					return;
				}

				bool removed = await _componentEditorService.RemoveComponentAsync(CurrentComponent);

				if ( removed )
				{
					SetCurrentModComponent(c: null);

					await ProcessComponentsAsync(MainConfig.AllComponents);
				}
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private async void SetDirectories_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				IStorageFolder startFolder = null;
				if ( !(MainConfig.DestinationPath is null) )
					startFolder = await StorageProvider.TryGetFolderFromPathAsync(MainConfig.DestinationPath.FullName);

				string[] result = await _dialogService.ShowFileDialogAsync(
					windowName: "Select your <<kotorDirectory>> (path to the game install)",
					isFolderDialog: true,
					startFolder: startFolder
				);
				if ( result?.Length > 0 )
				{
					string chosenFolder = result[0];
					if ( chosenFolder != null )
					{
						var kotorInstallDir = new DirectoryInfo(chosenFolder);
						MainConfigInstance.destinationPath = kotorInstallDir;
					}
				}
				else
				{
					await Logger.LogVerboseAsync("User cancelled selecting <<kotorDirectory>>");
				}
				if ( !(MainConfig.SourcePath is null) )
					startFolder = await StorageProvider.TryGetFolderFromPathAsync(MainConfig.SourcePath.FullName) ?? startFolder;

				result = await _dialogService.ShowFileDialogAsync(
					windowName: "Select your <<modDirectory>> where ALL your mods are downloaded.",
					isFolderDialog: true,
					startFolder: startFolder
				);
				if ( result?.Length > 0 )
				{
					string chosenFolder = result[0];
					if ( chosenFolder != null )
					{
						var modDirectory = new DirectoryInfo(chosenFolder);
						MainConfigInstance.sourcePath = modDirectory;
					}
				}
				else
				{
					await Logger.LogVerboseAsync(message: "User cancelled selecting <<modDirectory>>");
				}

				UpdateStepProgress();
			}
			catch ( ArgumentNullException ) { }
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex, customMessage: "Unknown error - please report to a developer");
			}
		}

		[UsedImplicitly]
		private async void InstallModSingle_Click([CanBeNull] object sender, [CanBeNull] RoutedEventArgs e)
		{
			try
			{
				if ( _installRunning )
				{
					await InformationDialog.ShowInformationDialogAsync(
						this,
						message: "There's already another installation running, please check the output window."
					);
					return;
				}
				if ( MainConfigInstance is null || MainConfig.DestinationPath is null )
				{
					var informationDialog = new InformationDialog { InfoText = "Please set your directories first" };
					_ = await informationDialog.ShowDialog<bool?>(this);
					return;
				}
				if ( CurrentComponent is null )
				{
					var informationDialog = new InformationDialog
					{
						InfoText = "Please choose a mod to install from the left list first",
					};
					_ = await informationDialog.ShowDialog<bool?>(this);
					return;
				}
				string name = CurrentComponent.Name;
				bool? confirm = await ConfirmationDialog.ShowConfirmationDialogAsync(
					this,
					CurrentComponent.Directions
					+ Environment.NewLine
					+ Environment.NewLine
					+ "Press Yes to execute the provided directions now."
				);
				if ( confirm != true )
				{
					await Logger.LogAsync($"User cancelled install of '{name}'");
					return;
				}
				try
				{
					_installRunning = true;
					var startTime = DateTime.UtcNow;
					ModComponent.InstallExitCode exitCode;

					using ( var activity = _telemetryService?.StartActivity($"mod.install.{name}") )
					{
						activity?.SetTag("mod.name", name);
						activity?.SetTag("mod.guid", CurrentComponent.Guid);

						exitCode = await InstallationService.InstallSingleComponentAsync(
							CurrentComponent,
							MainConfig.AllComponents
						);
						_installRunning = false;

						var duration = DateTime.UtcNow - startTime;
						bool success = exitCode == 0;

						_telemetryService?.RecordModInstallation(
							name,
							success,
							duration.TotalMilliseconds,
							success ? null : Utility.GetEnumDescription(exitCode)?.ToString()
						);
					}

					if ( exitCode != 0 )
					{
						await InformationDialog.ShowInformationDialogAsync(
							this,
							$"There was a problem installing '{name}':"
							+ Environment.NewLine
							+ Utility.GetEnumDescription(exitCode)
							+ Environment.NewLine
							+ Environment.NewLine
							+ " Check the output window for details."
						);
					}
					else
					{
						await Logger.LogAsync($"Successfully installed '{name}'");

						UpdateStepProgress();
					}
				}
				catch ( Exception )
				{
					_installRunning = false;
					throw;
				}
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private void StartInstall_Click([CanBeNull] object sender, [NotNull] RoutedEventArgs e)
		{
			_telemetryService?.RecordUIInteraction("click", "StartInstallButton");
			_telemetryService?.RecordEvent("installation.started", new Dictionary<string, object>
			{
				["selected_mod_count"] = MainConfig.AllComponents.Count(c => c.IsSelected),
				["total_mod_count"] = MainConfig.AllComponents.Count,
			});

			Task.Run(async () =>
			{
				try
				{
					if ( _installRunning )
					{
						await Dispatcher.UIThread.InvokeAsync(async () =>
						{
							await InformationDialog.ShowInformationDialogAsync(
								this,
								message: "There's already an installation running, please check the output window."
							);
						});
						return;
					}

					(bool success, string informationMessage) = await InstallationService.ValidateInstallationEnvironmentAsync(
						MainConfigInstance,
						async message => await ConfirmationDialog.ShowConfirmationDialogAsync(this, message) == true
					);

					if ( !success )
					{
						await Dispatcher.UIThread.InvokeAsync(async () =>
						{
							await InformationDialog.ShowInformationDialogAsync(this, informationMessage);
						});
						return;
					}

					await Dispatcher.UIThread.InvokeAsync(async () =>
					{
						await StartInstallationProcess();
					});
				}
				catch ( Exception ex )
				{
					await Logger.LogExceptionAsync(ex);
				}
			});
		}

		private async Task StartInstallationProcess()
		{
			try
			{

				UpdateStepProgress();
				if ( await ConfirmationDialog.ShowConfirmationDialogAsync(
						this,
						"WARNING! While there is code in place to prevent incorrect instructions from running,"
						+ $" the program cannot predict every possible mistake a user could make in a config file.{Environment.NewLine}"
						+ " KOTORModSync now uses a checkpoint system that tracks file changes after each mod installation."
						+ " You can rollback to any checkpoint if something goes wrong."
						+ $" However, you should still back up your Install directory before proceeding.{Environment.NewLine}{Environment.NewLine}"
						+ " Are you sure you're ready to continue?"
					)
					!= true )
				{
					return;
				}
				if ( await ConfirmationDialog.ShowConfirmationDialogAsync(this, confirmText: "Really install all mods?") != true )
					return;
				var progressWindow = new ProgressWindow { ProgressBar = { Value = 0 }, Topmost = true };
				DateTime installStartTime = DateTime.UtcNow;
				int warningCount = 0;
				int errorCount = 0;
				void LogCounter(string message)
				{
					try
					{
						if ( string.IsNullOrEmpty(message) )
							return;

						if ( message.IndexOf(value: "[Warning]", StringComparison.OrdinalIgnoreCase) >= 0 )
							warningCount++;
						if ( message.IndexOf(value: "[Error]", StringComparison.OrdinalIgnoreCase) >= 0 )
							errorCount++;
					}
					catch { }
				}
				void ExceptionCounter(Exception _)
				{
					try { errorCount++; }
					catch ( Exception ex )
					{
						Logger.LogException(ex);
					}
				}
				Logger.Logged += LogCounter;
				Logger.ExceptionLogged += ExceptionCounter;
				progressWindow.CancelRequested += (_, __) =>

					progressWindow.Close();
				_isClosingProgressWindow = false;
				if ( Utility.GetOperatingSystem() == OSPlatform.Windows )
				{
					_ = Logger.LogVerboseAsync("Disabling the close button on the console window, to prevent an install from being interrupted...");
					ConsoleConfig.DisableConsoleCloseButton();
				}
			// Checkpoint system disabled - clean start-to-finish installation
			/*
			Core.Services.ImmutableCheckpoint.CheckpointService checkpointService = null;
			string currentSessionId = null;

			// Start checkpoint session
			if ( MainConfig.DestinationPath != null )
			{
				try
				{
					checkpointService = new Core.Services.ImmutableCheckpoint.CheckpointService(
						MainConfig.DestinationPath.FullName
					);
					currentSessionId = await checkpointService.StartInstallationSessionAsync();
					await Logger.LogAsync($"Checkpoint session started: {currentSessionId}");
				}
				catch ( Exception ex )
				{
					await Logger.LogErrorAsync($"Failed to initialize checkpoint system: {ex.Message}");
					await Logger.LogErrorAsync("Installation will continue without checkpoint support.");
				}
			}
			*/

			try
			{
				_ = Logger.LogAsync("Start installing all mods...");
				_installRunning = true;

					progressWindow.Closed += ProgressWindowClosed;
					progressWindow.Closing += async (sender2, e2) =>
					{

						if ( _isClosingProgressWindow )
							return;

						e2.Cancel = true;

						bool? result = await ConfirmationDialog.ShowConfirmationDialogAsync(
							this,
							confirmText:
							"Closing the progress window will stop the install after the current instruction completes. Really cancel the install?"
						);

						if ( !(result is true) )
							return;

						_isClosingProgressWindow = true;

						progressWindow.Close();
					};
					progressWindow.Show();
					_progressWindowClosed = false;
					ModComponent.InstallExitCode exitCode = ModComponent.InstallExitCode.UnknownError;
					var selectedMods = MainConfig.AllComponents.Where(thisComponent => thisComponent.IsSelected).ToList();
					for ( int index = 0; index < selectedMods.Count; index++ )
					{
						if ( _progressWindowClosed )
						{
							_installRunning = false;
							_ = Logger.LogAsync(message: "User cancelled install by closing the progress window.");
							return;
						}
						ModComponent component = selectedMods[index];
						await Dispatcher.UIThread.InvokeAsync(
							async () =>
							{
								progressWindow.ProgressTextBlock.Text = $"Installing '{component.Name}'..."
																		+ Environment.NewLine
																		+ Environment.NewLine
																		+ "Executing the provided directions..."
																		+ Environment.NewLine
																		+ Environment.NewLine
																		+ component.Directions;
								double percentComplete = selectedMods.Count == 0 ? 0 : (double)index / selectedMods.Count;
								progressWindow.Topmost = true;
								int installedCount = index;
								progressWindow.UpdateMetrics(
									percentComplete,
									installedCount,
									selectedMods.Count,
									installStartTime,
									warningCount,
									errorCount,
									component.Name
								);

								await Task.Delay(millisecondsDelay: 100);
								await Dispatcher.UIThread.InvokeAsync(() => { });
								await Task.Delay(millisecondsDelay: 50);
							}
						);

						await Task.Yield();
						await Task.Delay(millisecondsDelay: 200);
						if ( !component.IsSelected )
						{
							await Logger.LogAsync($"Skipping install of '{component.Name}' (unchecked)");
							continue;
						}
						await Logger.LogAsync($"Start Install of '{component.Name}'...");


						if ( component.WidescreenOnly && !string.IsNullOrWhiteSpace(MainConfig.WidescreenSectionContent) )
						{
							bool shouldContinue = await ShowWidescreenNotificationAsync();
							if ( !shouldContinue )
							{
								await Logger.LogAsync(message: "Install cancelled by user at widescreen notification");
								exitCode = ModComponent.InstallExitCode.UserCancelledInstall;
								break;
							}
						}

						exitCode = await InstallationService.InstallSingleComponentAsync(
							component,
							MainConfig.AllComponents
						);
						await Logger.LogAsync($"Install of '{component.Name}' finished with exit code {exitCode}");
						if ( exitCode != 0 )
						{
							bool? confirm = await ConfirmationDialog.ShowConfirmationDialogAsync(
								this,
								$"There was a problem installing '{component.Name}':"
								+ Environment.NewLine
								+ Utility.GetEnumDescription(exitCode)
								+ Environment.NewLine
								+ Environment.NewLine
								+ " Check the output window for details."
								+ Environment.NewLine
								+ Environment.NewLine
								+ $"Skip '{component.Name}' and install the next mod anyway? (NOT RECOMMENDED!)"
							);
							if ( confirm == true )
								continue;
							await Logger.LogAsync(message: "Install cancelled");
							break;
						}
					await Logger.LogAsync($"Finished installed '{component.Name}'");

					// Checkpoint system disabled
					/*
					if ( checkpointService != null && !string.IsNullOrEmpty(currentSessionId) )
					{
						try
						{
							await Dispatcher.UIThread.InvokeAsync(() =>
							{
								progressWindow.ProgressTextBlock.Text = $"Creating checkpoint for '{component.Name}'..."
																		+ Environment.NewLine
																		+ "Scanning for file changes...";
							});

							string checkpointId = await checkpointService.CreateCheckpointAsync(
								component.Name,
								component.Guid.ToString()
							);
							await Logger.LogAsync($"Checkpoint created: {checkpointId}");
						}
						catch ( Exception ex )
						{
							await Logger.LogErrorAsync($"Failed to create checkpoint: {ex.Message}");
							await Logger.LogErrorAsync("Installation will continue, but this checkpoint is unavailable.");
						}
					}
					*/
					}
					if ( exitCode != ModComponent.InstallExitCode.Success )
						return;
					await InformationDialog.ShowInformationDialogAsync(
						this,
						message: "Install Completed. Check the output window for information."
					);
					await Logger.LogAsync(message: "Install completed.");

					UpdateStepProgress();
				}
				catch ( Exception )
				{
					await Logger.LogErrorAsync(message: "Terminating install due to unhandled exception:");
					throw;
				}
			finally
			{
				// Checkpoint system disabled
				/*
				if ( checkpointService != null && !string.IsNullOrEmpty(currentSessionId) )
				{
					try
					{
						await checkpointService.CompleteSessionAsync(keepCheckpoints: true);
						await Logger.LogAsync("Checkpoint session completed successfully");
					}
					catch ( Exception ex )
					{
						await Logger.LogErrorAsync($"Failed to complete checkpoint session: {ex.Message}");
					}
				}
				*/

					_installRunning = false;
					_isClosingProgressWindow = true;
					progressWindow.Close();

					Logger.Logged -= LogCounter;
					Logger.ExceptionLogged -= ExceptionCounter;
				}
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		private void ProgressWindowClosed([CanBeNull] object sender, [CanBeNull] EventArgs e)
		{
			try
			{
				if ( !(sender is ProgressWindow progressWindow) )
					return;
				progressWindow.ProgressBar.Value = 0;
				progressWindow.Closed -= ProgressWindowClosed;
				progressWindow.Dispose();
				_progressWindowClosed = true;
				if ( Utility.GetOperatingSystem() != OSPlatform.Windows )
					return;
				_ = Logger.LogVerboseAsync("Install terminated, re-enabling the close button in the console window");
				ConsoleConfig.EnableCloseButton();
			}
			catch ( Exception exception )
			{
				Logger.LogException(exception);
			}
		}

		[UsedImplicitly]
		private async void DocsButton_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{

				if ( MainConfig.AllComponents == null || MainConfig.AllComponents.Count == 0 )
				{
					await InformationDialog.ShowInformationDialogAsync(
						this,
						message: "No mod components available to generate documentation."
					);
					return;
				}

				string file = await SaveFileAsync(
					saveFileName: "ModList_Documentation.md"
				);

				if ( file is null )
				{
					await Logger.LogVerboseAsync("Documentation export cancelled by user.");
					return;
				}

				await Logger.LogAsync($"Generating documentation for {MainConfig.AllComponents.Count} mod component(s)...");
				string docs = ModComponentSerializationService.GenerateModDocumentation(
					MainConfig.AllComponents,
					MainConfig.BeforeModListContent,
					MainConfig.AfterModListContent,
					MainConfig.WidescreenSectionContent,
					MainConfig.AspyrSectionContent);

				if ( string.IsNullOrWhiteSpace(docs) )
				{
					await Logger.LogWarningAsync("Generated documentation is empty.");
					await InformationDialog.ShowInformationDialogAsync(
						this,
						message: "The generated documentation is empty. Please check your mod components."
					);
					return;
				}

				await FileUtilities.SaveDocsToFileAsync(file, docs);

				string successMessage = $"Successfully generated and saved documentation for {MainConfig.AllComponents.Count} mod component(s) to:\n\n{file}";
				await Logger.LogAsync($"Documentation saved to '{file}'");
				await InformationDialog.ShowInformationDialogAsync(this, successMessage);
			}
			catch ( IOException ioEx )
			{
				await Logger.LogExceptionAsync(ioEx, customMessage: "IO error while saving documentation file");
				await InformationDialog.ShowInformationDialogAsync(
					this,
					message: $"Failed to save documentation file. The file may be in use or the path may be invalid.\n\nError: {ioEx.Message}"
				);
			}
			catch ( UnauthorizedAccessException uaEx )
			{
				await Logger.LogExceptionAsync(uaEx, customMessage: "Access denied while saving documentation");
				await InformationDialog.ShowInformationDialogAsync(
					this,
					message: $"Access denied while saving the documentation file. Please check file permissions.\n\nError: {uaEx.Message}"
				);
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex, customMessage: "Unexpected error generating and saving documentation");
				await InformationDialog.ShowInformationDialogAsync(
					this,
					message: $"An unexpected error occurred while generating and saving documentation.\n\nError: {ex.Message}"
				);
			}
		}


		[UsedImplicitly]
		private async void TabControl_SelectionChanged([NotNull] object sender, [NotNull] SelectionChangedEventArgs e)
		{
			try
			{
				await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] START - IgnoreInternalTabChange={IgnoreInternalTabChange}");
				if ( IgnoreInternalTabChange )
				{
					await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Ignoring internal tab change, returning early");
					return;
				}
				try
				{
					if ( !(sender is TabControl tabControl) )
					{
						await Logger.LogErrorAsync(message: "[TabControl_SelectionChanged] Sender is not a TabControl control");
						return;
					}
					await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] TabControl found, SelectedIndex={tabControl.SelectedIndex}");
					if ( CurrentComponent is null )
					{
						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] CurrentComponent is null, tabs can't be used");
						SetTabInternal(tabControl, InitialTab);
						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Set to InitialTab");
						return;
					}
					await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] CurrentComponent='{CurrentComponent.Name}' (GUID={CurrentComponent.Guid})");

					if ( e.RemovedItems.IsNullOrEmptyOrAllNull() || !(e.RemovedItems[0] is TabItem lastSelectedTabItem) )
					{
						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Previous tab item could not be resolved");
						return;
					}
					await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] Previous tab: '{lastSelectedTabItem.Header}' (IsVisible={lastSelectedTabItem.IsVisible})");

					if ( e.AddedItems.IsNullOrEmptyOrAllNull() || !(e.AddedItems[0] is TabItem attemptedTabSelection) )
					{
						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Attempted tab item could not be resolved");
						return;
					}
					await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] Target tab: '{attemptedTabSelection.Header}' (IsVisible={attemptedTabSelection.IsVisible})");

					if ( MainConfig.AllComponents.IsNullOrEmptyCollection() || CurrentComponent is null )
					{
						await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] No config loaded (ComponentCount={MainConfig.AllComponents.Count}), defaulting to initial tab");
						SetTabInternal(tabControl, InitialTab);
						return;
					}
					string tabName = GetControlNameFromHeader(attemptedTabSelection)?.ToLowerInvariant();
					string lastTabName = GetControlNameFromHeader(lastSelectedTabItem)?.ToLowerInvariant();
					await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] TabNames: from='{lastTabName}' to='{tabName}'");

					if ( tabName == lastTabName )
					{
						await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] Selected tab is already the current tab '{tabName}', returning");
						return;
					}
					await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] Preparing to swap tabs from '{lastTabName}' to '{tabName}'");
					bool shouldSwapTabs = true;
					if ( tabName == "summary" )
					{

						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Target is 'summary', refreshing markdown content");
						RenderMarkdownContent(CurrentComponent);
					}
					else if ( tabName == "raw" )
					{
						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Target is 'raw', loading into RawTabControl");
						await LoadIntoRawEditTextBoxAsync(CurrentComponent);
						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] LoadIntoRawEditTextBox completed");
					}
					else if ( lastTabName == "raw" )
					{
						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Source was 'raw', checking if changes should be saved");
						shouldSwapTabs = await ShouldSaveChangesAsync();
						await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] ShouldSaveChanges returned: {shouldSwapTabs}");
						if ( shouldSwapTabs )
						{
							await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Unloading raw editor");
							RawTabControl.GetRawEditTextBox().Text = string.Empty;
						}
					}
					else if ( tabName == "editor" )
					{
						await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] Target is 'editor', CurrentComponent='{CurrentComponent?.Name}', InstructionCount={CurrentComponent?.Instructions.Count}, OptionCount={CurrentComponent?.Options.Count}");
					}

					if ( !shouldSwapTabs )
					{
						await Logger.LogVerboseAsync("[TabControl_SelectionChanged] shouldSwapTabs=false, reverting to previous tab");
						SetTabInternal(tabControl, lastSelectedTabItem);
						return;
					}
					await Logger.LogVerboseAsync("[TabControl_SelectionChanged] Setting visibility for controls based on selected tab");

					RawTabControl.GetRawEditTextBox().IsVisible = tabName == "raw";
					await Logger.LogVerboseAsync($"[TabControl_SelectionChanged] RawEditTextBox.IsVisible={RawTabControl.GetRawEditTextBox().IsVisible}");
					await Logger.LogVerboseAsync("[TabControl_SelectionChanged] COMPLETED SUCCESSFULLY");
				}
				catch ( Exception exception )
				{
					await Logger.LogExceptionAsync(exception, customMessage: "[TabControl_SelectionChanged] Inner exception");
				}
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex, customMessage: "[TabControl_SelectionChanged] Outer exception");
			}
		}

		[UsedImplicitly]
		private void ComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			try
			{

				if ( !(sender is ComboBox comboBox) )
				{
					Logger.Log(message: "Sender is not a ComboBox.");
					return;
				}

				if ( !(comboBox.DataContext is Instruction thisInstruction) )
				{
					Logger.Log(message: "ComboBox's DataContext must be an instruction for this method.");
					return;
				}

				string selectedItem = comboBox.SelectedItem as string;

				var itemsList = comboBox.Items.Cast<string>().ToList();
				int index = itemsList.IndexOf(selectedItem);

				thisInstruction.Arguments = index.ToString();
				thisInstruction.Action = Instruction.ActionType.Patcher;
			}
			catch ( Exception exception )
			{
				Logger.LogException(exception);
			}
		}

		[CanBeNull]
		private TabItem GetCurrentTabItem([CanBeNull] TabControl tabControl) =>
			(tabControl ?? TabControl)?.SelectedItem as TabItem;

		[CanBeNull]
		private static string GetControlNameFromHeader([CanBeNull] TabItem tabItem) => tabItem?.Header?.ToString();
		private void SetTabInternal([NotNull] TabControl tabControl, TabItem tabItem)
		{
			if ( tabControl is null )
				throw new ArgumentNullException(nameof(tabControl));
			IgnoreInternalTabChange = true;
			tabControl.SelectedItem = tabItem;
			IgnoreInternalTabChange = false;
		}

		private async void LoadComponentDetails([NotNull] ModComponent selectedComponent)
		{
			if ( selectedComponent == null )
				throw new ArgumentNullException(nameof(selectedComponent));
			await Logger.LogVerboseAsync($"[LoadComponentDetails] START for component '{selectedComponent.Name}' (GUID={selectedComponent.Guid})");
			await Logger.LogVerboseAsync($"[LoadComponentDetails] CurrentComponent={(CurrentComponent == null ? "null" : $"'{CurrentComponent.Name}' (GUID={CurrentComponent.Guid})")}");

			if ( selectedComponent == CurrentComponent )
			{
				await Logger.LogVerboseAsync("[LoadComponentDetails] Same component already loaded, no action needed");
				return;
			}

			bool confirmLoadOverwrite = true;
			string currentTabName = GetControlNameFromHeader(GetCurrentTabItem(TabControl))?.ToLowerInvariant();
			await Logger.LogVerboseAsync($"[LoadComponentDetails] Current tab: '{currentTabName}'");

			if ( currentTabName == "raw" && CurrentComponent != null )
			{
				await Logger.LogVerboseAsync("[LoadComponentDetails] Current tab is 'raw' and switching components, checking if changes should be saved");
				confirmLoadOverwrite = await ShouldSaveChangesAsync();
				await Logger.LogVerboseAsync($"[LoadComponentDetails] ShouldSaveChanges returned: {confirmLoadOverwrite}");
			}

			if ( !confirmLoadOverwrite )
			{
				await Logger.LogVerboseAsync("[LoadComponentDetails] Load cancelled by user, returning");
				return;
			}

			await Logger.LogVerboseAsync($"[LoadComponentDetails] Setting CurrentComponent to '{selectedComponent.Name}'");
			SetCurrentModComponent(selectedComponent);
			await Logger.LogVerboseAsync("[LoadComponentDetails] SetCurrentComponent completed");

			if ( currentTabName == "raw" )
			{
				await Logger.LogVerboseAsync("[LoadComponentDetails] Current tab is 'raw', loading new component into RawTabControl");
				await LoadIntoRawEditTextBoxAsync(selectedComponent);
				await Logger.LogVerboseAsync("[LoadComponentDetails] LoadIntoRawEditTextBox completed");
			}

			await Logger.LogVerboseAsync($"[LoadComponentDetails] InitialTab.IsSelected={InitialTab.IsSelected}, TabControl.SelectedIndex={TabControl.SelectedIndex}");
			if ( InitialTab.IsSelected || TabControl.SelectedIndex == int.MaxValue )
			{
				await Logger.LogVerboseAsync("[LoadComponentDetails] Switching to SummaryTabItem");
				SetTabInternal(TabControl, SummaryTabItem);
			}
			else
			{
				await Logger.LogVerboseAsync($"[LoadComponentDetails] Keeping current tab '{currentTabName}'");
			}
			await Logger.LogVerboseAsync("[LoadComponentDetails] COMPLETED");
		}

		public void SetCurrentModComponent([CanBeNull] ModComponent c)
		{
			Logger.LogVerbose($"[SetCurrentComponent] START with component={(c == null ? "null" : $"'{c.Name}' (GUID={c.Guid})")}");

			bool isNewComponent = c != null && c != CurrentComponent;
			Logger.LogVerbose($"[SetCurrentComponent] isNewComponent={isNewComponent}, CurrentComponent={(CurrentComponent == null ? "null" : $"'{CurrentComponent.Name}'")}");
			Logger.LogVerbose("[SetCurrentComponent] Setting CurrentComponent property");
			CurrentComponent = c;
			Logger.LogVerbose("[SetCurrentComponent] CurrentComponent property set");
			Logger.LogVerbose($"[SetCurrentComponent] Setting EditorTabControl.CurrentComponent (current={(EditorTabControl.CurrentComponent == null ? "null" : "not null")})");
			EditorTabControl.CurrentComponent = c;
			Logger.LogVerbose($"[SetCurrentComponent] EditorTabControl.CurrentComponent set to {(c == null ? "null" : $"'{c.Name}'")}");
			Logger.LogVerbose($"[SetCurrentComponent] Setting SummaryTabControl.CurrentComponent");
			SummaryTabControl.CurrentComponent = c;
			Logger.LogVerbose($"[SetCurrentComponent] SummaryTabControl.CurrentComponent set to {(c == null ? "null" : $"'{c.Name}'")}");
			if ( c == null )
			{
				Logger.LogVerbose("[SetCurrentComponent] ModComponent is null, returning early");
				return;
			}

			Logger.LogVerbose($"[SetCurrentComponent] Making tabs visible (Summary={SummaryTabItem.IsVisible}, GuiEdit={GuiEditTabItem.IsVisible}, RawEdit={RawEditTabItem.IsVisible})");
			if ( EditorMode )
			{
				SummaryTabItem.IsVisible = true;
				GuiEditTabItem.IsVisible = true;
				RawEditTabItem.IsVisible = true;

				if ( c.ModLink != null && c.ModLink.Count > 0 )
				{
					Task.Run(async () =>
					{
						try
						{
							await Logger.LogVerboseAsync($"[SetCurrentComponent] Pre-resolving URLs for component '{c.Name}' in editor mode");
							await _downloadCacheService.PreResolveUrlsAsync(c, _downloadCacheService._downloadManager, System.Threading.CancellationToken.None);
							await Logger.LogVerboseAsync($"[SetCurrentComponent] Pre-resolution completed for '{c.Name}'");
						}
						catch ( Exception ex )
						{
							await Logger.LogExceptionAsync(ex, $"[SetCurrentComponent] Error pre-resolving URLs for '{c.Name}'");
						}
					});
				}
			}
			Logger.LogVerbose("[SetCurrentComponent] Tabs visibility set to true");

			Logger.LogVerbose($"[SetCurrentComponent] Calling RefreshCategorySelectionControl for component '{c.Name}' with {c.Category.Count} categories");
			RefreshCategorySelectionControl();
			Logger.LogVerbose("[SetCurrentComponent] RefreshCategorySelectionControl completed");

			Logger.LogVerbose("[SetCurrentComponent] Rendering markdown content for Summary tab");
			RenderMarkdownContent(c);
			Logger.LogVerbose("[SetCurrentComponent] Markdown content rendering completed");

			Logger.LogVerbose($"[SetCurrentComponent] Tab check: isNewComponent={isNewComponent}, InitialTab.IsSelected={InitialTab.IsSelected}, SelectedIndex={TabControl.SelectedIndex}, GuiEditTabItem.IsSelected={GuiEditTabItem.IsSelected}, RawEditTabItem.IsSelected={RawEditTabItem.IsSelected}");

			if ( isNewComponent && RawEditTabItem.IsSelected )
			{
				Logger.LogVerbose("[SetCurrentComponent] New component and Raw tab is selected, updating raw editor content");
				Task.Run(async () =>
				{
					if ( await ShouldSaveChangesAsync() )
					{
						await LoadIntoRawEditTextBoxAsync(c);
						Logger.LogVerbose("[SetCurrentComponent] Raw editor content updated");
					}
				});
			}

			if (
				isNewComponent
				&& (
					InitialTab.IsSelected
					|| TabControl.SelectedIndex == int.MaxValue
					|| (
						!GuiEditTabItem.IsSelected
						&& !RawEditTabItem.IsSelected
					)
				) )
			{
				Logger.LogVerbose("[SetCurrentComponent] Switching to SummaryTabItem");
				SetTabInternal(TabControl, SummaryTabItem);
			}
			else
			{
				Logger.LogVerbose("[SetCurrentComponent] Not switching tabs");
			}
			Logger.LogVerbose("[SetCurrentComponent] COMPLETED");
		}

		private void RenderMarkdownContent([NotNull] ModComponent component)
		{
			_markdownRenderingService.RenderComponentMarkdown(
				component,
				SummaryTabControl.GetDescriptionTextBlock(),
				SummaryTabControl.GetDirectionsTextBlock(),
				SpoilerFreeMode
			);
		}

		private async Task LoadIntoRawEditTextBoxAsync([NotNull] ModComponent selectedComponent)
		{
			if ( selectedComponent is null )
				throw new ArgumentNullException(nameof(selectedComponent));

			string serializedContent = await Services.ComponentEditorService.LoadIntoRawEditorAsync(selectedComponent);
			RawTabControl.GetRawEditTextBox().Text = serializedContent;
		}

		private void RawEditTextBox_LostFocus([NotNull] object sender, [NotNull] RoutedEventArgs e) => e.Handled = true;

		private async Task<bool> LoadTomlFile(string filePath, string fileType = "instruction file")
		{
			bool result = await _fileLoadingService.LoadTomlFileAsync(filePath, EditorMode, () => ProcessComponentsAsync(MainConfig.AllComponents), fileType);
			if ( result )
			{
				_lastLoadedFileName = _fileLoadingService.LastLoadedFileName;
			}
			return result;
		}

		private async Task<bool> ShouldSaveChangesAsync(bool noPrompt = false)
		{
			try
			{

				bool result = await _componentEditorService.SaveChangesAsync(
					CurrentComponent,
					RawTabControl.GetRawEditTextBox().Text,
					noPrompt
				);

				if ( result && CurrentComponent != null )
				{

					await ProcessComponentsAsync(MainConfig.AllComponents);
				}

				return result;
			}
			catch ( Exception ex )
			{
				string output = "An unexpected exception was thrown. Please refer to the output window for details and report this issue to a developer.";
				await Logger.LogExceptionAsync(ex);
				await InformationDialog.ShowInformationDialogAsync(this, output + Environment.NewLine + ex.Message);
				return false;
			}
		}

		private async void MoveComponentListItem([CanBeNull] ModComponent componentToMove, int relativeIndex)
		{
			try
			{
				if ( componentToMove == null )
					return;
				_ = ModManagementService.MoveModRelative(componentToMove, relativeIndex);
				await ProcessComponentsAsync(MainConfig.AllComponents);
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		private void OnModOperationCompleted(object sender, ModOperationEventArgs e)
		{
			try
			{
				switch ( e.Operation )
				{
					case ModOperation.Create:
					case ModOperation.Delete:
					case ModOperation.Move:
						Dispatcher.UIThread.Post(() =>
						{

							Task _ = ProcessComponentsAsync(MainConfig.AllComponents)
								.ContinueWith(t =>
								{
									try
									{
										if ( t.Exception != null )
										{

											Logger.LogException(t.Exception.Flatten());
										}
										else
										{
											UpdateModCounts();
										}
									}
									catch ( Exception ex )
									{
										Logger.LogException(ex);
									}
								}, TaskScheduler.FromCurrentSynchronizationContext());
						});
						break;
					case ModOperation.Read:
					case ModOperation.Update:
					case ModOperation.Duplicate:
					case ModOperation.AddDependency:
					case ModOperation.RemoveDependency:
					case ModOperation.AddRestriction:
					case ModOperation.RemoveRestriction:
					case ModOperation.Batch:
						break;
					default:
						throw new ArgumentOutOfRangeException(nameof(e), $"Unexpected ModOperation value: {e.Operation}");
				}
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		private void OnModValidationCompleted(object sender, ModValidationEventArgs e)
		{
			try
			{

				Dispatcher.UIThread.Post(UpdateModCounts);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}

		[UsedImplicitly]
		private void MoveUpButton_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) =>
			MoveComponentListItem(CurrentComponent, relativeIndex: -1);

		[UsedImplicitly]
		private void MoveDownButton_Click([NotNull] object sender, [NotNull] RoutedEventArgs e) =>
			MoveComponentListItem(CurrentComponent, relativeIndex: 1);

		[UsedImplicitly]
		private void GenerateGuidButton_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				RawTabControl.GetGuidTextBox().Text = Guid.NewGuid().ToString();
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}

		[UsedImplicitly]
		private async void SaveModFileAs_Click([CanBeNull] object sender, [CanBeNull] RoutedEventArgs e, string format = "toml")
		{
			try
			{

				string extension;
				if ( format == "yaml" )
					extension = ".yaml";
				else if ( format == "md" )
					extension = ".md";
				else
					extension = ".toml";

				string defaultFileName = !string.IsNullOrEmpty(_lastLoadedFileName)
					? Path.ChangeExtension(_lastLoadedFileName, extension.TrimStart('.'))
					: $"my_mod_instructions{extension}";

				string filePath = await SaveFileAsync(saveFileName: defaultFileName);
				if ( filePath == null )
					return;

				bool success = false;
				switch ( format )
				{
					case "yaml":
						success = await MainWindow.SaveYamlFileAsync(filePath);
						break;
					case "md":
						success = await MainWindow.SaveMarkdownFileAsync(filePath);
						break;
					default:
						success = await _fileLoadingService.SaveTomlFileAsync(filePath, MainConfig.AllComponents);
						break;
				}

				if ( success )
				{
					_lastLoadedFileName = Path.GetFileName(filePath);
					await Logger.LogAsync($"Successfully saved file as {format.ToUpper()}: {filePath}");
				}
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		private static async Task<bool> SaveYamlFileAsync(string filePath)
		{
			try
			{

				var sb = new System.Text.StringBuilder();

				MainWindow.WriteYamlMetadataSection(sb);

				foreach ( var component in MainConfig.AllComponents )
				{
					sb.AppendLine("---");
					sb.AppendLine(component.SerializeComponent());
				}

				File.WriteAllText(filePath, sb.ToString());
				await Logger.LogAsync($"Saved {MainConfig.AllComponents.Count} components to YAML file: {filePath}");
				return true;
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex, "Failed to save YAML file");
				return false;
			}
		}

		private static void WriteYamlMetadataSection(System.Text.StringBuilder sb)
		{
			bool hasAnyMetadata = !string.IsNullOrWhiteSpace(MainConfig.TargetGame)
				|| !string.IsNullOrWhiteSpace(MainConfig.BuildName)
				|| !string.IsNullOrWhiteSpace(MainConfig.BuildAuthor)
				|| !string.IsNullOrWhiteSpace(MainConfig.BuildDescription)
				|| MainConfig.LastModified.HasValue;

			if ( !hasAnyMetadata && MainConfig.FileFormatVersion == "2.0" )
				return;

			sb.AppendLine("---");
			sb.AppendLine("# Metadata");
			sb.AppendLine($"fileFormatVersion: \"{MainConfig.FileFormatVersion}\"");

			if ( !string.IsNullOrWhiteSpace(MainConfig.TargetGame) )
				sb.AppendLine($"targetGame: \"{MainConfig.TargetGame}\"");

			if ( !string.IsNullOrWhiteSpace(MainConfig.BuildName) )
				sb.AppendLine($"buildName: \"{MainConfig.BuildName}\"");

			if ( !string.IsNullOrWhiteSpace(MainConfig.BuildAuthor) )
				sb.AppendLine($"buildAuthor: \"{MainConfig.BuildAuthor}\"");

			if ( !string.IsNullOrWhiteSpace(MainConfig.BuildDescription) )
			{
				string escapedDescription = MainConfig.BuildDescription
					.Replace("\\", "\\\\")
					.Replace("\"", "\\\"")
					.Replace("\n", "\\n")
					.Replace("\r", "\\r")
					.Replace("\t", "\\t");
				sb.AppendLine($"buildDescription: \"{escapedDescription}\"");
			}

			if ( MainConfig.LastModified.HasValue )
				sb.AppendLine($"lastModified: \"{MainConfig.LastModified.Value:O}\"");

			sb.AppendLine();
		}

		private static async Task<bool> SaveMarkdownFileAsync(string filePath)
		{
			try
			{

				string markdown = ModComponentSerializationService.GenerateModDocumentation(
					MainConfig.AllComponents,
					MainConfig.BeforeModListContent,
					MainConfig.AfterModListContent,
					MainConfig.WidescreenSectionContent,
					MainConfig.AspyrSectionContent);
				File.WriteAllText(filePath, markdown);
				await Logger.LogAsync($"Saved {MainConfig.AllComponents.Count} components to Markdown file: {filePath}");
				return true;
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex, "Failed to save Markdown file");
				return false;
			}
		}

		public void ComponentCheckboxChecked(
			[NotNull] ModComponent component,
				[NotNull] HashSet<ModComponent> visitedComponents,
				bool suppressErrors = false
			)
		{
			_componentSelectionService.HandleComponentChecked(component, visitedComponents, suppressErrors, RefreshSingleComponentVisuals);
		}

		public void ComponentCheckboxUnchecked(
			[NotNull] ModComponent component,
				[CanBeNull] HashSet<ModComponent> visitedComponents,
				bool suppressErrors = false
			)
		{
			_componentSelectionService.HandleComponentUnchecked(component, visitedComponents ?? new HashSet<ModComponent>(), suppressErrors, RefreshSingleComponentVisuals);
			if ( !suppressErrors )
				UpdateModCounts();
		}

		private void OnCheckBoxChanged(object sender, RoutedEventArgs e)
		{
			try
			{
				Logger.LogVerbose($"[OnCheckBoxChanged] START - sender type: {sender?.GetType().Name ?? "null"}");

				if ( _suppressComponentCheckboxEvents )
				{
					Logger.LogVerbose("[OnCheckBoxChanged] Suppressing component checkbox events, returning");
					return;
				}

				if ( !(sender is CheckBox checkBox) )
				{
					Logger.LogVerbose("[OnCheckBoxChanged] Sender is not a CheckBox, returning");
					return;
				}

				var visualPath = new List<string>();
				var current = checkBox.Parent;
				while ( current != null && visualPath.Count < 5 )
				{
					visualPath.Add($"{current.GetType().Name}(Name='{current.Name}')");
					current = current.Parent;
				}
				Logger.LogVerbose($"[OnCheckBoxChanged] Visual tree path: {string.Join(" -> ", visualPath)}");

				if ( checkBox.Tag is ModComponent thisComponent )
				{
					Logger.LogVerbose($"[OnCheckBoxChanged] ModComponent: '{thisComponent.Name}' (GUID={thisComponent.Guid}), IsChecked={checkBox.IsChecked}");
					if ( checkBox.IsChecked == true )
					{
						Logger.LogVerbose($"[OnCheckBoxChanged] Checking component '{thisComponent.Name}'");
						ComponentCheckboxChecked(thisComponent, new HashSet<ModComponent>());
					}
					else if ( checkBox.IsChecked == false )
					{
						Logger.LogVerbose($"[OnCheckBoxChanged] Unchecking component '{thisComponent.Name}'");
						ComponentCheckboxUnchecked(thisComponent, new HashSet<ModComponent>());
					}
					else
					{
						Logger.LogVerbose($"[OnCheckBoxChanged] Could not determine checkBox state for component '{thisComponent.Name}' (IsChecked={checkBox.IsChecked})");
					}
					Logger.LogVerbose("[OnCheckBoxChanged] Updating step progress and mod counts");

					UpdateStepProgress();
					UpdateModCounts();

					ResetDownloadStatusDisplay();
					Logger.LogVerbose("[OnCheckBoxChanged] COMPLETED");
				}
				else if ( checkBox.Tag is Option thisOption )
				{
					Logger.LogVerbose($"[OnCheckBoxChanged] Option: '{thisOption.Name}' (GUID={thisOption.Guid}), IsChecked={checkBox.IsChecked}");

					ModComponent parentComponent = MainConfig.AllComponents.FirstOrDefault(c => c.Options.Contains(thisOption));

					if ( parentComponent != null )
					{
						if ( checkBox.IsChecked == true )
						{

							_componentSelectionService.HandleOptionChecked(thisOption, parentComponent, RefreshSingleComponentVisuals);
						}
						else if ( checkBox.IsChecked == false )
						{

							_componentSelectionService.HandleOptionUnchecked(thisOption, parentComponent, RefreshSingleComponentVisuals);
						}

						UpdateModCounts();
						UpdateStepProgress();
						ResetDownloadStatusDisplay();
					}

					Logger.LogVerbose("[OnCheckBoxChanged] COMPLETED (Option)");
				}
				else
				{
					Logger.LogVerbose($"CheckBox.Tag is neither a ModComponent nor an Option!");
					return;
				}
			}
			catch ( Exception exception )
			{
				Logger.LogException(exception, customMessage: "[OnCheckBoxChanged] Exception occurred");
				Console.WriteLine(exception);
			}
		}

		public void OnComponentCheckBoxChanged(object sender, RoutedEventArgs e) => OnCheckBoxChanged(sender, e);

		private void SummaryOptionBorder_PointerPressed(object sender, PointerPressedEventArgs e)
		{

			e.Handled = true;

			if ( sender is Border border && border.Tag is Option option )
			{

				option.IsSelected = !option.IsSelected;

				if ( option.IsSelected )
				{
					border.Background = ThemeResourceHelper.ModListItemHoverBackgroundBrush;
				}
				else
				{
					border.Background = Brushes.Transparent;
				}
			}
		}

		private async Task ProcessComponentsAsync([NotNull][ItemNotNull] List<ModComponent> modComponentsList)
		{
			try
			{

				ModListBox?.Items.Clear();

				ComponentProcessingResult result = await Core.Services.ComponentProcessingService.ProcessComponentsAsync(modComponentsList);
				if ( result.IsEmpty )
				{

					SummaryTabItem.IsVisible = false;
					GuiEditTabItem.IsVisible = false;
					RawEditTabItem.IsVisible = false;
					SetTabInternal(TabControl, InitialTab);
					UpdateStepProgress();
					UpdateModCounts();
					return;
				}
				if ( !result.Success && result.HasCircularDependencies )
				{

					CircularDependencyDetector.CircularDependencyResult cycleInfo =
						CircularDependencyDetector.DetectCircularDependencies(modComponentsList);

					if ( cycleInfo.HasCircularDependencies && cycleInfo.Cycles.Count > 0 )
					{
						(bool retry, List<ModComponent> resolvedComponents) = await CircularDependencyResolutionDialog.ShowResolutionDialog(
							this,
							modComponentsList,
							cycleInfo);
						if ( retry && resolvedComponents != null )
						{

							await ProcessComponentsAsync(resolvedComponents);
						}
					}
					return;
				}

				List<ModComponent> componentsToProcess = result.ReorderedComponents ?? result.Components;

				PopulateModList(componentsToProcess);
				if ( componentsToProcess.Count > 0 || TabControl is null )
				{

					if ( EditorMode )
					{
						SummaryTabItem.IsVisible = true;
						GuiEditTabItem.IsVisible = true;
						RawEditTabItem.IsVisible = true;
					}

					UpdateStepProgress();

					return;
				}

				SummaryTabItem.IsVisible = false;
				GuiEditTabItem.IsVisible = false;
				RawEditTabItem.IsVisible = false;
				SetTabInternal(TabControl, InitialTab);

				UpdateStepProgress();
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private async void AddNewInstruction_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				await Logger.LogVerboseAsync($"[AddNewInstruction_Click] START - CurrentComponent={(CurrentComponent == null ? "null" : $"'{CurrentComponent.Name}'")}");
				if ( CurrentComponent is null )
				{
					await Logger.LogVerboseAsync("[AddNewInstruction_Click] CurrentComponent is null, showing dialog");
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				var addButton = (Button)sender;
				await Logger.LogVerboseAsync($"[AddNewInstruction_Click] Button tag type: {addButton.Tag?.GetType().Name ?? "null"}");
				var thisInstruction = addButton.Tag as Instruction;
				var thisComponent = addButton.Tag as ModComponent;
				if ( thisInstruction is null && thisComponent is null )
				{
					await Logger.LogErrorAsync("[AddNewInstruction_Click] Cannot find instruction or component instance from button tag");
					throw new NullReferenceException(message: "Cannot find instruction instance from button.");
				}
				int index;
				if ( !(thisComponent is null) )
				{
					await Logger.LogVerboseAsync($"[AddNewInstruction_Click] Tag is ModComponent '{thisComponent.Name}', creating new instruction");
					thisInstruction = new Instruction();
					index = thisComponent.Instructions.Count;
					await Logger.LogVerboseAsync($"[AddNewInstruction_Click] Creating instruction at index {index} (total instructions: {thisComponent.Instructions.Count})");
					thisComponent.CreateInstruction(index);
				}
				else
				{
					await Logger.LogVerboseAsync("[AddNewInstruction_Click] Tag is Instruction, getting parent component");
					ModComponent parentComponent = thisInstruction.GetParentComponent();
					await Logger.LogVerboseAsync($"[AddNewInstruction_Click] Parent component: '{parentComponent?.Name}'");
					index = parentComponent?.Instructions.IndexOf(thisInstruction) ?? throw new NullReferenceException($"Could not get index of instruction '{thisInstruction.Action}' in null parentComponent'");
					await Logger.LogVerboseAsync($"[AddNewInstruction_Click] Creating instruction at index {index}");
					parentComponent.CreateInstruction(index);
				}
				await Logger.LogVerboseAsync($"[AddNewInstruction_Click] Instruction '{thisInstruction.Action}' created at index #{index} for component '{CurrentComponent.Name}'");
				await Logger.LogVerboseAsync("[AddNewInstruction_Click] Calling LoadComponentDetails");
				LoadComponentDetails(CurrentComponent);
				await Logger.LogVerboseAsync("[AddNewInstruction_Click] COMPLETED");
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception, customMessage: "[AddNewInstruction_Click] Exception occurred");
			}
		}

		[UsedImplicitly]
		private async void DeleteInstruction_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				Instruction thisInstruction = (Instruction)((Button)sender).Tag
					?? throw new NullReferenceException($"Could not get instruction instance from button's tag: {((Button)sender).Content}");
				int index = thisInstruction.GetParentComponent().Instructions.IndexOf(thisInstruction);
				InstructionManagementService.DeleteInstruction(thisInstruction.GetParentComponent(), index);
				LoadComponentDetails(CurrentComponent);
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}

		[UsedImplicitly]
		private async void AutoGenerateInstructions_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				await Logger.LogVerboseAsync($"[AutoGenerateInstructions_Click] START - CurrentComponent='{CurrentComponent.Name}'");

				bool? useModLinks = await ConfirmationDialog.ShowConfirmationDialogAsync(
					this,
					"Where would you like to source these instructions from?",
					"From Mod Links",
					"From Archive on Disk");
				if ( useModLinks == null )
				{
					await Logger.LogVerboseAsync("[AutoGenerateInstructions_Click] User cancelled source selection");
					return;
				}

				if ( CurrentComponent.Instructions.Count > 0 )
				{
					bool? confirmed = await ConfirmationDialog.ShowConfirmationDialogAsync(
						this,
						"Replace Existing Instructions",
						"This will replace all existing instructions with auto-generated ones. Continue?");
					if ( confirmed != true )
					{
						await Logger.LogVerboseAsync("[AutoGenerateInstructions_Click] User cancelled replacement confirmation");
						return;
					}
				}
				if ( useModLinks == true )
				{
					await GenerateInstructionsFromModLinks();
				}
				else
				{
					await GenerateInstructionsFromArchive();
				}
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
				await InformationDialog.ShowInformationDialogAsync(this, message: $"Error generating instructions: {exception.Message}");
			}
		}
		private async Task GenerateInstructionsFromModLinks()
		{
			int result = await _instructionGenerationService.GenerateInstructionsFromModLinksAsync(CurrentComponent);
			if ( result > 0 )
				LoadComponentDetails(CurrentComponent);
		}
		private async Task GenerateInstructionsFromArchive()
		{
			bool success = await _instructionGenerationService.GenerateInstructionsFromArchiveAsync(CurrentComponent, () => _dialogService.ShowFileDialogAsync(false, false, null, "Select the mod archive to analyze for auto-generation"));
			if ( success )
				LoadComponentDetails(CurrentComponent);
		}

		private static string GetRelativePath(string basePath, string targetPath)
		{
			if ( string.IsNullOrEmpty(basePath) || string.IsNullOrEmpty(targetPath) )
				return targetPath;

			basePath = Path.GetFullPath(basePath);
			targetPath = Path.GetFullPath(targetPath);

			if ( !targetPath.StartsWith(basePath, StringComparison.OrdinalIgnoreCase) )
				return Path.GetFileName(targetPath);

			string relativePath = targetPath.Substring(basePath.Length);
			if ( relativePath.StartsWith(Path.DirectorySeparatorChar.ToString()) )
				relativePath = relativePath.Substring(1);
			return relativePath;
		}

		private async Task<string> DownloadModFromUrl(string url)
		{
			return await DownloadOrchestrationService.DownloadModFromUrlAsync(url, CurrentComponent);
		}
		[UsedImplicitly]
		private async void MoveInstructionUp_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				var thisInstruction = (Instruction)((Button)sender).Tag;
				int index = CurrentComponent.Instructions.IndexOf(thisInstruction);
				if ( thisInstruction is null )
				{
					await Logger.LogExceptionAsync(new InvalidOperationException(message: "The sender does not correspond to a instruction."));
					return;
				}
				InstructionManagementService.MoveInstruction(CurrentComponent, thisInstruction, index - 1);
				LoadComponentDetails(CurrentComponent);
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		[UsedImplicitly]
		private async void MoveInstructionDown_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				var thisInstruction = (Instruction)((Button)sender).Tag;
				int index = CurrentComponent.Instructions.IndexOf(thisInstruction);
				if ( thisInstruction is null )
					throw new NullReferenceException($"Could not get instruction instance from button's tag: {((Button)sender).Content}");
				InstructionManagementService.MoveInstruction(CurrentComponent, thisInstruction, index + 1);
				LoadComponentDetails(CurrentComponent);
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		[UsedImplicitly]
		private void OpenOutputWindow_Click([CanBeNull] object sender, [CanBeNull] RoutedEventArgs e)
		{
			if ( _outputWindow?.IsVisible == true )
				_outputWindow.Close();
			_outputWindow = new OutputWindow();
			_outputWindow.Show();
		}
		[UsedImplicitly]
		private async void OpenSettings_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				var settingsDialog = new SettingsDialog();
				settingsDialog.InitializeFromMainWindow(this);
				bool result = await settingsDialog.ShowDialog<bool>(this);
				if ( !result )
					return;

				string selectedTheme = settingsDialog.GetSelectedTheme();
				ApplyTheme(selectedTheme);

				SaveSettings();
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		[UsedImplicitly]
		private async void OpenCheckpointManagement_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( MainConfig.DestinationPath == null || !Directory.Exists(MainConfig.DestinationPath.FullName) )
				{
					var dialog = new Dialogs.MessageDialog(
						"No Destination Path",
						"Please set a KOTOR installation directory before managing checkpoints.",
						"OK"
					);
					await dialog.ShowDialog(this);
					return;
				}

				var checkpointDialog = new Dialogs.CheckpointManagementDialog(MainConfig.DestinationPath.FullName);
				await checkpointDialog.ShowDialog(this);
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}
		[UsedImplicitly]
		private void CreateGithubIssue_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				UrlUtilities.OpenUrl("https://github.com/th3w1zard1/KOTORModSync/issues/new");
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Failed to open GitHub issue creation page");
			}
		}

		[UsedImplicitly]
		private void OpenSponsorPage_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				UrlUtilities.OpenUrl("https://github.com/sponsors/th3w1zard1");
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Failed to open GitHub Sponsors page");
			}
		}
		private static void ApplyTheme(string stylePath)
		{
			ThemeService.ApplyTheme(stylePath);
		}
		[UsedImplicitly]
		private async void StyleComboBox_SelectionChanged(
			[NotNull] object sender,
			[NotNull] SelectionChangedEventArgs e
		)
		{
			try
			{
				if ( _initialize )
				{
					_initialize = false;
					return;
				}
				if ( !(sender is ComboBox comboBox) )
					return;
				var selectedItem = (ComboBoxItem)comboBox.SelectedItem;
				if ( !(selectedItem?.Tag is string stylePath) )
				{
					await Logger.LogErrorAsync("stylePath cannot be rendered from tag, returning immediately");
					return;
				}

				ThemeService.ApplyTheme(stylePath);
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		[UsedImplicitly]
		private void ToggleMaximizeButton_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			if ( !(sender is Button maximizeButton) )
				return;
			if ( WindowState == WindowState.Maximized )
			{
				WindowState = WindowState.Normal;
				maximizeButton.Content = "â–¢";
			}
			else
			{
				WindowState = WindowState.Maximized;
				maximizeButton.Content = "â–£";
			}
		}
		[UsedImplicitly]
		private async void AddNewOption_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				await Logger.LogVerboseAsync($"[AddNewOption_Click] START - CurrentComponent={(CurrentComponent == null ? "null" : $"'{CurrentComponent.Name}'")}");
				if ( CurrentComponent is null )
				{
					await Logger.LogVerboseAsync("[AddNewOption_Click] CurrentComponent is null, showing dialog");
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				var addButton = (Button)sender;
				await Logger.LogVerboseAsync($"[AddNewOption_Click] Button tag type: {addButton.Tag?.GetType().Name ?? "null"}");
				var thisOption = addButton.Tag as Option;
				var thisComponent = addButton.Tag as ModComponent;
				if ( thisOption is null && thisComponent is null )
				{
					await Logger.LogErrorAsync("[AddNewOption_Click] Cannot find option or component instance from button tag");
					throw new NullReferenceException("Cannot find option instance from button.");
				}
				int index;
				if ( thisOption is null )
				{
					await Logger.LogVerboseAsync("[AddNewOption_Click] Tag is ModComponent, creating new option");
					thisOption = new Option();
					index = CurrentComponent.Options.Count;
					await Logger.LogVerboseAsync($"[AddNewOption_Click] Creating option at index {index} (total options: {CurrentComponent.Options.Count})");
				}
				else
				{
					await Logger.LogVerboseAsync($"[AddNewOption_Click] Tag is Option '{thisOption.Name}', getting index");
					index = CurrentComponent.Options.IndexOf(thisOption);
					await Logger.LogVerboseAsync($"[AddNewOption_Click] Creating option at index {index}");
				}
				CurrentComponent.CreateOption(index);
				await Logger.LogVerboseAsync($"[AddNewOption_Click] Option '{thisOption.Name}' created at index #{index} for component '{CurrentComponent.Name}'");
				await Logger.LogVerboseAsync("[AddNewOption_Click] Calling LoadComponentDetails");
				LoadComponentDetails(CurrentComponent);

				RefreshSingleComponentVisuals(CurrentComponent);
				await Logger.LogVerboseAsync("[AddNewOption_Click] COMPLETED");
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception, customMessage: "[AddNewOption_Click] Exception occurred");
			}
		}
		[UsedImplicitly]
		private async void DeleteOption_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				var thisOption = (Option)((Button)sender).Tag;
				int index = CurrentComponent.Options.IndexOf(thisOption);
				InstructionManagementService.DeleteOption(CurrentComponent, index);
				LoadComponentDetails(CurrentComponent);

				RefreshSingleComponentVisuals(CurrentComponent);
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		[UsedImplicitly]
		private async void MoveOptionUp_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				var thisOption = (Option)((Button)sender).Tag;
				int index = CurrentComponent.Options.IndexOf(thisOption);
				if ( thisOption is null )
					throw new NullReferenceException($"Could not get option instance from button's tag: {((Button)sender).Content}");
				InstructionManagementService.MoveOption(CurrentComponent, thisOption, index - 1);
				LoadComponentDetails(CurrentComponent);
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		[UsedImplicitly]
		private async void MoveOptionDown_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			try
			{
				if ( CurrentComponent is null )
				{
					await InformationDialog.ShowInformationDialogAsync(this, message: "Load a component first");
					return;
				}
				var thisOption = (Option)((Button)sender).Tag;
				int index = CurrentComponent.Options.IndexOf(thisOption);
				if ( thisOption is null )
					throw new NullReferenceException($"Could not get option instance from button's tag: {((Button)sender).Content}");
				InstructionManagementService.MoveOption(CurrentComponent, thisOption, index + 1);
				LoadComponentDetails(CurrentComponent);
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		private async void CopyTextToClipboard_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				if ( Clipboard is null )
					throw new NullReferenceException(nameof(Clipboard));
				await Clipboard.SetTextAsync((string)((MenuItem)sender).DataContext);
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}

		private void HomeButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{

				SetCurrentModComponent(null);

				TabControl tabControl = this.FindControl<TabControl>("TabControl");
				TabItem initialTab = this.FindControl<TabItem>("InitialTab");
				if ( tabControl != null && initialTab != null )
					SetTabInternal(tabControl, initialTab);
			}
			catch ( Exception exception )
			{
				Logger.LogException(exception);
			}
		}
		[UsedImplicitly]
		private async void Step1Button_Click(object sender, RoutedEventArgs e)
		{
			try
			{

				await ShowSetDirectoriesDialog();
				UpdateStepProgress();
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		private async void Step2Button_Click(object sender, RoutedEventArgs e)
		{
			try
			{

				await LoadInstructionFile();
				UpdateStepProgress();
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		private async void GettingStartedValidateButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				await RunValidation();
				UpdateStepProgress();

				ShowValidationResults();
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}
		private async void InstallButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				await StartInstallation();
				UpdateStepProgress();
			}
			catch ( Exception exception )
			{
				await Logger.LogExceptionAsync(exception);
			}
		}

		// GettingStartedTab event handlers for XAML bindings
		private void GettingStartedTab_AutoFixRequested(object sender, RoutedEventArgs e) => AutoFixButton_Click(sender, e);
		private void GettingStartedTab_CreateGithubIssueRequested(object sender, RoutedEventArgs e) => CreateGithubIssue_Click(sender, e);
		private void GettingStartedTab_DirectoryChangedRequested(object sender, DirectoryChangedEventArgs e) => OnDirectoryChanged(sender, e);
		private void GettingStartedTab_DownloadStatusRequested(object sender, RoutedEventArgs e) => DownloadStatusButton_Click(sender, e);
		private void GettingStartedTab_InstallRequested(object sender, RoutedEventArgs e) => InstallButton_Click(sender, e);
		private async void GettingStartedTab_JumpToCurrentStepRequested(object sender, RoutedEventArgs e) => await Task.Run(() => JumpToCurrentStep_Click(sender, e));
		private void GettingStartedTab_JumpToModRequested(object sender, RoutedEventArgs e) => JumpToModButton_Click(sender, e);
		private void GettingStartedTab_LoadInstructionFileRequested(object sender, RoutedEventArgs e) => Step2Button_Click(sender, e);
		private void GettingStartedTab_NextErrorRequested(object sender, RoutedEventArgs e) => NextErrorButton_Click(sender, e);
		private void GettingStartedTab_OpenModDirectoryRequested(object sender, RoutedEventArgs e) => OpenModDirectoryButton_Click(sender, e);
		private void GettingStartedTab_OpenOutputWindowRequested(object sender, RoutedEventArgs e) => OpenOutputWindow_Click(sender, e);
		private void GettingStartedTab_OpenSettingsRequested(object sender, RoutedEventArgs e) => OpenSettings_Click(sender, e);
		private void GettingStartedTab_OpenSponsorPageRequested(object sender, RoutedEventArgs e) => OpenSponsorPage_Click(sender, e);
		private void GettingStartedTab_PrevErrorRequested(object sender, RoutedEventArgs e) => PrevErrorButton_Click(sender, e);
		private async void GettingStartedTab_ScrapeDownloadsRequested(object sender, RoutedEventArgs e) => await Task.Run(() => ScrapeDownloadsButton_Click(sender, e));
		private void GettingStartedTab_StopDownloadsRequested(object sender, RoutedEventArgs e) => StopDownloadsButton_Click(sender, e);
		private async void GettingStartedTab_ValidateRequested(object sender, RoutedEventArgs e) => await Task.Run(() => GettingStartedValidateButton_Click(sender, e));

		private async Task ShowSetDirectoriesDialog()
		{

			Menu topMenu = this.FindControl<Menu>(name: "TopMenu");
			if ( topMenu?.Items.Count > 0 && topMenu.Items[1] is MenuItem fileMenu )
			{
				if ( fileMenu.Items.Count > 1 && fileMenu.Items[1] is MenuItem setDirItem )
				{

					await Task.Delay(millisecondsDelay: 100);
					SetDirectories_Click(setDirItem, new RoutedEventArgs());
				}
			}
		}
		private async Task LoadInstructionFile()
		{

			Menu topMenu = this.FindControl<Menu>(name: "TopMenu");
			if ( topMenu?.Items.Count > 0 && topMenu.Items[1] is MenuItem fileMenu )
			{
				if ( fileMenu.Items.Count > 0 && fileMenu.Items[0] is MenuItem loadFileItem )
				{

					await Task.Delay(millisecondsDelay: 100);
					LoadFile_Click(loadFileItem, new RoutedEventArgs());
				}
			}
		}
		private async Task RunValidation()
		{

			await Task.Delay(millisecondsDelay: 100);
			ValidateButton_Click(sender: null, new RoutedEventArgs());
		}
		private async Task StartInstallation()
		{

			await Task.Delay(millisecondsDelay: 100);
			StartInstall_Click(sender: null, new RoutedEventArgs());
		}

		private static bool IsStep1Complete() => ValidationService.IsStep1Complete();
		private void UpdateStepProgress()
		{
			try
			{
				_uiStateService.UpdateStepProgress(
					GettingStartedTabControl.FindControl<Border>("Step1Border"), GettingStartedTabControl.FindControl<Border>("Step1CompleteIndicator"), GettingStartedTabControl.FindControl<TextBlock>("Step1CompleteText"),
					GettingStartedTabControl.FindControl<Border>("Step2Border"), GettingStartedTabControl.FindControl<Border>("Step2CompleteIndicator"), GettingStartedTabControl.FindControl<TextBlock>("Step2CompleteText"),
					GettingStartedTabControl.FindControl<Border>("Step3Border"), GettingStartedTabControl.FindControl<Border>("Step3CompleteIndicator"), GettingStartedTabControl.FindControl<TextBlock>("Step3CompleteText"),
					GettingStartedTabControl.FindControl<Border>("Step4Border"), GettingStartedTabControl.FindControl<Border>("Step4CompleteIndicator"), GettingStartedTabControl.FindControl<TextBlock>("Step4CompleteText"),
					null, null, null,
					GettingStartedTabControl.FindControl<ProgressBar>("OverallProgressBar"), GettingStartedTabControl.FindControl<TextBlock>("ProgressText"),
					GettingStartedTabControl.FindControl<CheckBox>("Step4Checkbox"),
					EditorMode,
					IsComponentValidForInstallation
				);
			}
			catch ( Exception exception )
			{
				Logger.LogException(exception);
			}
		}

		private bool IsComponentValidForInstallation(ModComponent component) => _validationService.IsComponentValidForInstallation(component, EditorMode);

		private static bool AreModLinksValid(List<string> modLinks) => ValidationService.AreModLinksValid(modLinks);

		private static bool IsValidUrl(string url) => ValidationService.IsValidUrl(url);

		private void OnDirectoryChanged(object sender, DirectoryChangedEventArgs e)
		{
			try
			{
				switch ( e.PickerType )
				{
					case DirectoryPickerType.ModDirectory:

						MainConfigInstance.sourcePath = new DirectoryInfo(e.Path);
						Logger.Log($"Mod directory set to: {e.Path}");

						SyncDirectoryPickers(DirectoryPickerType.ModDirectory, e.Path);
						break;
					case DirectoryPickerType.KotorDirectory:

						MainConfigInstance.destinationPath = new DirectoryInfo(e.Path);
						Logger.Log($"KOTOR installation directory set to: {e.Path}");

						SyncDirectoryPickers(DirectoryPickerType.KotorDirectory, e.Path);
						break;
					default:
						throw new ArgumentOutOfRangeException(nameof(e.PickerType), e.PickerType, "Invalid DirectoryPickerType value in OnDirectoryChanged.");
				}

				UpdateStepProgress();
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		private void InitializeDirectoryPickers()
		{
			try
			{

				DirectoryPickerControl modPicker = this.FindControl<DirectoryPickerControl>("ModDirectoryPicker");
				DirectoryPickerControl kotorPicker = this.FindControl<DirectoryPickerControl>("KotorDirectoryPicker");
				DirectoryPickerControl step1ModPicker = GettingStartedTabControl.FindControl<DirectoryPickerControl>("Step1ModDirectoryPicker");
				DirectoryPickerControl step1KotorPicker = GettingStartedTabControl.FindControl<DirectoryPickerControl>("Step1KotorDirectoryPicker");
				if ( modPicker != null && MainConfig.SourcePath != null )
					modPicker.SetCurrentPath(MainConfig.SourcePath.FullName);
				if ( kotorPicker != null && MainConfig.DestinationPath != null )
					kotorPicker.SetCurrentPath(MainConfig.DestinationPath.FullName);
				if ( step1ModPicker != null && MainConfig.SourcePath != null )
					step1ModPicker.SetCurrentPath(MainConfig.SourcePath.FullName);
				if ( step1KotorPicker != null && MainConfig.DestinationPath != null )
					step1KotorPicker.SetCurrentPath(MainConfig.DestinationPath.FullName);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		public void SyncDirectoryPickers(DirectoryPickerType pickerType, string path)
		{
			try
			{
				var allPickers = new List<DirectoryPickerControl>();
				if ( pickerType == DirectoryPickerType.ModDirectory )
				{
					DirectoryPickerControl mainPicker = this.FindControl<DirectoryPickerControl>("ModDirectoryPicker");
					DirectoryPickerControl step1Picker = GettingStartedTabControl.FindControl<DirectoryPickerControl>("Step1ModDirectoryPicker");
					if ( mainPicker != null ) allPickers.Add(mainPicker);
					if ( step1Picker != null ) allPickers.Add(step1Picker);
				}
				else if ( pickerType == DirectoryPickerType.KotorDirectory )
				{
					DirectoryPickerControl mainPicker = this.FindControl<DirectoryPickerControl>("KotorDirectoryPicker");
					DirectoryPickerControl step1Picker = GettingStartedTabControl.FindControl<DirectoryPickerControl>("Step1KotorDirectoryPicker");
					if ( mainPicker != null ) allPickers.Add(mainPicker);
					if ( step1Picker != null ) allPickers.Add(step1Picker);
				}

				foreach ( DirectoryPickerControl picker in allPickers ) picker.SetCurrentPath(path);

				UpdateStepProgress();
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex);
			}
		}
		private void InitializeModDirectoryWatcher()
		{
			try
			{
				if ( MainConfig.SourcePath != null && Directory.Exists(MainConfig.SourcePath.FullName) )
					SetupModDirectoryWatcher(MainConfig.SourcePath.FullName);
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Failed to initialize mod directory watcher");
			}
		}
		private void SetupModDirectoryWatcher(string path)
		{
			_fileSystemService.SetupModDirectoryWatcher(path, UpdateDownloadStatus);

		}
		private void UpdateDownloadStatus()
		{

			Task.Run(() =>
			{
				try
				{
					if ( MainConfig.SourcePath == null || !Directory.Exists(MainConfig.SourcePath.FullName) )
						return;
					if ( MainConfig.AllComponents.Count == 0 )
						return;
					Logger.LogVerbose($"[FileValidation] Starting scan. Mod directory: {MainConfig.SourcePath.FullName}");
					int downloadedCount = 0;
					int totalSelected = 0;
					Logger.LogVerbose($"[FileValidation] Scanning {MainConfig.AllComponents.Count} components for download status");

					foreach ( ModComponent component in MainConfig.AllComponents )
					{
						if ( !component.IsSelected )
							continue;
						totalSelected++;
						Logger.LogVerbose($"[FileValidation] Checking component: {component.Name} (GUID: {component.Guid})");

						bool allUrlsCached = true;
						if ( component.ModLink != null && component.ModLink.Count > 0 )
						{
							Logger.LogVerbose($"[FileValidation] ModComponent has {component.ModLink.Count} URLs:");
							foreach ( string url in component.ModLink )
							{

								bool isCached = _downloadCacheService.IsCached(url);
								if ( isCached )
								{
									string cachedArchive = null;
									if ( _downloadCacheService.TryGetEntry(url, out DownloadCacheEntry entry) )
									{
										cachedArchive = entry.FileName;
									}
									Logger.LogVerbose($"[FileValidation]   URL: {url} - CACHED (Archive: {cachedArchive})");
								}
								else
								{
									Logger.LogVerbose($"[FileValidation]   URL: {url} - NOT CACHED");
									allUrlsCached = false;
								}
							}
						}
						else
						{
							Logger.LogVerbose($"[FileValidation] ModComponent has no URLs");
							allUrlsCached = false;
						}

						component.IsDownloaded = allUrlsCached;
						Logger.LogVerbose($"[FileValidation] ModComponent '{component.Name}': {(allUrlsCached ? "DOWNLOADED" : "MISSING")}");
						if ( allUrlsCached ) downloadedCount++;
					}

					Logger.LogVerbose($"Download scan complete: {downloadedCount}/{totalSelected} mods ready");

					Dispatcher.UIThread.Post(() =>
					{

						TextBlock statusText = GettingStartedTabControl.FindControl<TextBlock>("DownloadStatusText");
						if ( statusText != null )
						{
							if ( totalSelected == 0 )
							{
								statusText.Text = "No mods selected for installation.";
								statusText.Foreground = Brushes.Gray;
							}
							else if ( downloadedCount == totalSelected )
							{
								statusText.Text = $"âœ… All {totalSelected} selected mod(s) are downloaded!";
								statusText.Foreground = Brushes.Green;
							}
							else
							{
								statusText.Text = $"âš ï¸ {downloadedCount}/{totalSelected} selected mod(s) downloaded. {totalSelected - downloadedCount} missing.";
								statusText.Foreground = Brushes.Orange;
							}
						}

						RefreshModListItems();

						UpdateStepProgress();
					});
				}
				catch ( Exception ex )
				{
					Logger.LogException(ex, "Error scanning mod directory for downloads");
				}
			});
		}

		private void ResetDownloadStatusDisplay()
		{
			try
			{
				TextBlock statusText = GettingStartedTabControl.FindControl<TextBlock>("DownloadStatusText");
				if ( statusText != null )
				{

					statusText.Text = "Checking download status...";
					statusText.Foreground = Brushes.Gray;
				}
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Error resetting download status display");
			}
		}

		private static bool ValidateComponentFilesExist(ModComponent component)
		{
			return ValidationService.ValidateComponentFilesExist(component);
		}
		private async void ScrapeDownloadsButton_Click(object sender, RoutedEventArgs e)
		{
			HasFetchedDownloads = true;
			await _downloadOrchestrationService.StartDownloadSessionAsync(UpdateDownloadStatus);
		}

		private async void DownloadStatusButton_Click(object sender, RoutedEventArgs e)
		{
			await _downloadOrchestrationService.ShowDownloadStatusAsync();
		}

		private void StopDownloadsButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				_downloadOrchestrationService.CancelAllDownloads(closeWindow: true);
				Logger.Log("User requested to stop all downloads and close window");
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Error stopping downloads");
			}
		}

		private void InitializeDownloadAnimationTimer()
		{
			_downloadAnimationTimer = new DispatcherTimer
			{
				Interval = TimeSpan.FromMilliseconds(500)
			};
			_downloadAnimationTimer.Tick += (sender, e) =>
			{
				TextBlock runningText = GettingStartedTabControl.FindControl<TextBlock>("DownloadRunningText");
				if ( runningText != null && runningText.IsVisible )
				{
					_downloadAnimationDots = (_downloadAnimationDots + 1) % 4;
					string dots = new string('.', _downloadAnimationDots);
					runningText.Text = $"Running{dots}";
				}
			};
		}

		private void OnDownloadStateChanged(object sender, EventArgs e)
		{
			Dispatcher.UIThread.Post(() =>
			{
				try
				{
					UpdateDownloadIndicators();
				}
				catch ( Exception ex )
				{
					Logger.LogException(ex, "Error updating download indicators");
				}
			});
		}

		private void UpdateDownloadIndicators()
		{
			try
			{
				Avalonia.Controls.Shapes.Ellipse ledIndicator = GettingStartedTabControl.FindControl<Avalonia.Controls.Shapes.Ellipse>("DownloadLedIndicator");
				TextBlock runningText = GettingStartedTabControl.FindControl<TextBlock>("DownloadRunningText");
				Button stopButton = GettingStartedTabControl.FindControl<Button>("StopDownloadsButton");
				TextBlock progressText = GettingStartedTabControl.FindControl<TextBlock>("DownloadProgressText");

				bool isDownloadInProgress = _downloadOrchestrationService.IsDownloadInProgress;

				if ( ledIndicator != null )
				{
					ledIndicator.Fill = isDownloadInProgress
						? new SolidColorBrush(Color.FromRgb(0, 255, 0))
						: new SolidColorBrush(Color.FromRgb(128, 128, 128));
				}

				if ( runningText != null )
				{
					runningText.IsVisible = isDownloadInProgress;
				}

				if ( stopButton != null )
				{
					stopButton.IsVisible = isDownloadInProgress;
				}

				if ( progressText != null )
				{
					progressText.IsVisible = isDownloadInProgress;
					if ( isDownloadInProgress )
					{
						int completed = _downloadOrchestrationService.CompletedComponents;
						int total = _downloadOrchestrationService.TotalComponentsToDownload;
						progressText.Text = $"Downloaded: {completed} / {total} mods";
					}
				}

				if ( isDownloadInProgress )
				{
					if ( !_downloadAnimationTimer.IsEnabled )
					{
						_downloadAnimationDots = 0;
						_downloadAnimationTimer.Start();
					}
				}
				else
				{
					if ( _downloadAnimationTimer.IsEnabled )
					{
						_downloadAnimationTimer.Stop();
					}
				}
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Error in UpdateDownloadIndicators");
			}
		}
		private void OpenModDirectoryButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				if ( MainConfig.SourcePath == null || !Directory.Exists(MainConfig.SourcePath.FullName) )
				{
					Logger.LogWarning("Mod directory is not set or does not exist.");
					return;
				}

				if ( Utility.GetOperatingSystem() == OSPlatform.Windows )
					_ = System.Diagnostics.Process.Start("explorer.exe", MainConfig.SourcePath.FullName);
				else if ( Utility.GetOperatingSystem() == OSPlatform.OSX )
					_ = System.Diagnostics.Process.Start("open", MainConfig.SourcePath.FullName);
				else
					_ = System.Diagnostics.Process.Start("xdg-open", MainConfig.SourcePath.FullName);
				Logger.Log($"Opened mod directory: {MainConfig.SourcePath.FullName}");
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Failed to open mod directory");
			}
		}

		private static async Task TryAutoGenerateInstructionsForComponents(List<ModComponent> components)
		{
			await Core.Services.ComponentProcessingService.TryAutoGenerateInstructionsForComponentsAsync(components);
		}
		#region Selection Methods

		private readonly ObservableCollection<TierFilterItem> _tierItems = new ObservableCollection<TierFilterItem>();
		private readonly ObservableCollection<SelectionFilterItem> _categoryItems = new ObservableCollection<SelectionFilterItem>();
		private void RefreshCategorySelectionControl()
		{
			try
			{
				Logger.LogVerbose($"[RefreshCategorySelectionControl] START - CurrentComponent={(CurrentComponent == null ? "null" : $"'{CurrentComponent.Name}'")}");
				Logger.LogVerbose($"[RefreshCategorySelectionControl] AllComponents count={MainConfig.AllComponents.Count}");

				// CategorySelectionControl is inside EditorTabControl, not directly in MainWindow
				CategorySelectionControl categoryControl = EditorTabControl?.FindControl<CategorySelectionControl>("CategorySelectionControl");
				Logger.LogVerbose($"[RefreshCategorySelectionControl] CategorySelectionControl found: {categoryControl != null}");
				if ( categoryControl != null )
				{
					Logger.LogVerbose($"[RefreshCategorySelectionControl] Calling RefreshCategories with {MainConfig.AllComponents.Count} components");
					categoryControl.RefreshCategories(MainConfig.AllComponents);
					Logger.LogVerbose("[RefreshCategorySelectionControl] RefreshCategories completed");

					if ( CurrentComponent != null )
					{
						Logger.LogVerbose($"[RefreshCategorySelectionControl] Setting SelectedCategories from CurrentComponent (count={CurrentComponent.Category.Count})");
						if ( CurrentComponent.Category.Count > 0 )
						{
							Logger.LogVerbose($"[RefreshCategorySelectionControl] Categories to set: {string.Join(", ", CurrentComponent.Category)}");
						}
						categoryControl.SelectedCategories = CurrentComponent.Category;
						Logger.LogVerbose("[RefreshCategorySelectionControl] SelectedCategories set");
					}
					else
					{
						Logger.LogVerbose("[RefreshCategorySelectionControl] CurrentComponent is null, not setting SelectedCategories");
					}
				}
				else
				{
					Logger.LogVerbose("[RefreshCategorySelectionControl] CategorySelectionControl is null, cannot refresh");
				}
				Logger.LogVerbose("[RefreshCategorySelectionControl] COMPLETED");
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, customMessage: "[RefreshCategorySelectionControl] Exception occurred");
			}
		}
		private void SelectAll_Click(object sender, RoutedEventArgs e)
		{
			_selectionService.SelectAll((component, visited) => ComponentCheckboxChecked(component, visited));
			UpdateModCounts();
			RefreshModListVisuals();
			UpdateStepProgress();
		}

		private void DeselectAll_Click(object sender, RoutedEventArgs e)
		{
			try
			{

				_suppressComponentCheckboxEvents = true;

				_selectionService.DeselectAll((component, visited) => ComponentCheckboxUnchecked(component, visited));

				UpdateModCounts();
				RefreshModListVisuals();
				UpdateStepProgress();
				ResetDownloadStatusDisplay();
			}
			finally
			{

				_suppressComponentCheckboxEvents = false;
			}
		}
		private void InitializeFilterUi(List<ModComponent> components)
		{
			_filterUIService.InitializeFilters(components, ModListSidebar?.TierSelectionComboBox, ModListSidebar?.CategorySelectionItemsControl);
		}
		private void CategoryItem_PropertyChanged(object sender, PropertyChangedEventArgs e)
		{

		}
		private void SelectByTier_Click(object sender, RoutedEventArgs e)
		{
			var selectedTier = ModListSidebar?.TierSelectionComboBox?.SelectedItem as TierFilterItem;
			_filterUIService.SelectByTier(selectedTier, (c, visited) => ComponentCheckboxChecked(c, visited), () =>
			{
				UpdateModCounts();
				RefreshModListVisuals();
				UpdateStepProgress();
			});
		}
		private void ClearCategorySelection_Click(object sender, RoutedEventArgs e)
		{
			_filterUIService.ClearCategorySelections((item, handler) => item.PropertyChanged += handler);
		}
		private void ApplyCategorySelections_Click(object sender, RoutedEventArgs e)
		{
			_filterUIService.ApplyCategorySelections((c, visited) => ComponentCheckboxChecked(c, visited), () =>
			{
				UpdateModCounts();
				RefreshModListVisuals();
				UpdateStepProgress();
			});
		}
		// EditorTab event forwarders - these handlers are now handled internally by EditorTab
		private void EditorTab_ExpandAllSectionsRequested(object sender, RoutedEventArgs e) { /* EditorTab handles this internally */ }
		private void EditorTab_CollapseAllSectionsRequested(object sender, RoutedEventArgs e) { /* EditorTab handles this internally */ }
		private void EditorTab_AutoGenerateInstructionsRequested(object sender, RoutedEventArgs e) => AutoGenerateInstructions_Click(sender, e);
		private void EditorTab_AddNewInstructionRequested(object sender, RoutedEventArgs e) => AddNewInstruction_Click(sender, e);
		private void EditorTab_DeleteInstructionRequested(object sender, RoutedEventArgs e) => DeleteInstruction_Click(sender, e);
		private void EditorTab_BrowseDestinationRequested(object sender, RoutedEventArgs e) => BrowseDestination_Click(sender, e);
		private void EditorTab_BrowseSourceFilesRequested(object sender, RoutedEventArgs e) => BrowseSourceFiles_Click(sender, e);
		private void EditorTab_BrowseSourceFromFoldersRequested(object sender, RoutedEventArgs e) => BrowseSourceFromFolders_Click(sender, e);
		private void EditorTab_MoveInstructionUpRequested(object sender, RoutedEventArgs e) => MoveInstructionUp_Click(sender, e);
		private void EditorTab_MoveInstructionDownRequested(object sender, RoutedEventArgs e) => MoveInstructionDown_Click(sender, e);
		private void EditorTab_AddNewOptionRequested(object sender, RoutedEventArgs e) => AddNewOption_Click(sender, e);
		private void EditorTab_DeleteOptionRequested(object sender, RoutedEventArgs e) => DeleteOption_Click(sender, e);
		private void EditorTab_MoveOptionUpRequested(object sender, RoutedEventArgs e) => MoveOptionUp_Click(sender, e);
		private void EditorTab_MoveOptionDownRequested(object sender, RoutedEventArgs e) => MoveOptionDown_Click(sender, e);

		private async void EditorTab_JumpToBlockingInstructionRequested(object sender, Core.Services.Validation.PathValidationResult e)
		{
			try
			{
				if ( e == null || CurrentComponent == null )
					return;

				// Handle jump to ModLinks scenario
				if ( e.NeedsModLinkAdded )
				{
					await Logger.LogWarningAsync($"File exists but is not provided by instructions or ModLinks.");
					await Logger.LogAsync($"Please upload this file to mega.nz or another hosting service and add the URL to your ModLinks.");
					await Logger.LogAsync($"Tip: The ModLinks section is in the 'Raw' tab. Look for the 'ModLink = [' section.");

					// Switch to Raw tab if possible
					if ( TabControl != null )
					{
						TabControl.SelectedIndex = 2; // Raw tab is typically index 2
					}

					return;
				}

				// Handle jump to blocking instruction scenario
				if ( !e.BlockingInstructionIndex.HasValue )
					return;

				int targetIndex = e.BlockingInstructionIndex.Value;
				if ( targetIndex < 0 || targetIndex >= CurrentComponent.Instructions.Count )
					return;

				Instruction targetInstruction = CurrentComponent.Instructions[targetIndex];

				await Logger.LogAsync($"Jumping to blocking instruction #{targetIndex + 1} ({targetInstruction.Action})");

				// Ensure the Instructions expander is open in the Editor tab
				if ( EditorTabControl != null )
				{
					// The expanders are in the EditorTab control - we can't directly access them here
					// But the user can see the issue and manually expand if needed
				}

				// Show a message to help the user
				await Logger.LogWarningAsync($"Instruction #{targetIndex + 1} ({targetInstruction.Action}) is preventing later instructions from being validated.");
				await Logger.LogAsync($"Please fix instruction #{targetIndex + 1} first. The issue: {e.DetailedMessage}");

			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}

		// RawTab event forwarders
		private void RawTab_ApplyEditorChangesRequested(object sender, RoutedEventArgs e) => RawTabApply_Click(sender, e);
		private void RawTab_GenerateGuidRequested(object sender, RoutedEventArgs e) => GenerateGuidButton_Click(sender, e);

		// SummaryTab event forwarders
		private void SummaryTab_OpenLinkRequested(object sender, Avalonia.Input.TappedEventArgs e) => OpenLink_Click(sender, e);
		private void SummaryTab_CopyTextToClipboardRequested(object sender, RoutedEventArgs e) => CopyTextToClipboard_Click(sender, e);
		private void SummaryTab_SummaryOptionPointerPressedRequested(object sender, Avalonia.Input.PointerPressedEventArgs e) => SummaryOptionBorder_PointerPressed(sender, e);
		private void SummaryTab_CheckBoxChangedRequested(object sender, RoutedEventArgs e) => OnCheckBoxChanged(sender, e);
		private void SummaryTab_JumpToInstructionRequested(object sender, RoutedEventArgs e) => JumpToInstruction_Click(sender, e);

		[UsedImplicitly]
		private async void JumpToCurrentStep_Click(object sender, RoutedEventArgs e)
		{
			try
			{

				ScrollViewer scrollViewer = GettingStartedTabControl.FindControl<ScrollViewer>("PART_ScrollViewer");
				if ( scrollViewer == null )
				{
					// Try finding the first ScrollViewer in the control
					scrollViewer = GettingStartedTabControl.GetVisualDescendants().OfType<ScrollViewer>().FirstOrDefault();
				}

				if ( scrollViewer == null )
					return;

				await _stepNavigationService.JumpToCurrentStepAsync(scrollViewer, name => GettingStartedTabControl.FindControl<Border>(name));
			}
			catch ( Exception ex )
			{
				await Logger.LogExceptionAsync(ex);
			}
		}
		#region Validation Results Display

		private void ShowValidationResults()
		{
			_validationDisplayService.ShowValidationResults(
				GettingStartedTabControl.FindControl<Border>("ValidationResultsArea"),
				GettingStartedTabControl.FindControl<TextBlock>("ValidationSummaryText"),
				GettingStartedTabControl.FindControl<Border>("ErrorNavigationArea"),
				GettingStartedTabControl.FindControl<Border>("ErrorDetailsArea"),
				GettingStartedTabControl.FindControl<Border>("ValidationSuccessArea"),
				IsComponentValidForInstallation
			);
		}

		private (string ErrorType, string Description, bool CanAutoFix) GetComponentErrorDetails(ModComponent component)
		{
			return _validationService.GetComponentErrorDetails(component);
		}
		private void PrevErrorButton_Click(object sender, RoutedEventArgs e)
		{
			_validationDisplayService.NavigateToPreviousError(
				GettingStartedTabControl.FindControl<TextBlock>("ErrorCounterText"),
				GettingStartedTabControl.FindControl<TextBlock>("ErrorModNameText"),
				GettingStartedTabControl.FindControl<TextBlock>("ErrorTypeText"),
				GettingStartedTabControl.FindControl<TextBlock>("ErrorDescriptionText"),
				GettingStartedTabControl.FindControl<Button>("AutoFixButton"),
				GettingStartedTabControl.FindControl<Button>("PrevErrorButton"),
				GettingStartedTabControl.FindControl<Button>("NextErrorButton")
			);
		}

		private void NextErrorButton_Click(object sender, RoutedEventArgs e)
		{
			_validationDisplayService.NavigateToNextError(
				GettingStartedTabControl.FindControl<TextBlock>("ErrorCounterText"),
				GettingStartedTabControl.FindControl<TextBlock>("ErrorModNameText"),
				GettingStartedTabControl.FindControl<TextBlock>("ErrorTypeText"),
				GettingStartedTabControl.FindControl<TextBlock>("ErrorDescriptionText"),
				GettingStartedTabControl.FindControl<Button>("AutoFixButton"),
				GettingStartedTabControl.FindControl<Button>("PrevErrorButton"),
				GettingStartedTabControl.FindControl<Button>("NextErrorButton")
			);
		}

		private void AutoFixButton_Click(object sender, RoutedEventArgs e)
		{
			if ( _validationDisplayService.AutoFixCurrentError(RefreshSingleComponentVisuals) )
				ShowValidationResults();
		}

		private void JumpToModButton_Click(object sender, RoutedEventArgs e)
		{
			try
			{
				ModComponent currentError = _validationDisplayService.GetCurrentError();
				if ( currentError == null )
					return;

				(string ErrorType, string Description, bool CanAutoFix) = _validationService.GetComponentErrorDetails(currentError);

				if ( ModListBox?.ItemsSource != null )
				{
					ModListBox.SelectedItem = currentError;
					ModListBox.ScrollIntoView(currentError);
				}

				TabControl tabControl = this.FindControl<TabControl>("TabControl");
				if ( tabControl != null )
				{

					if ( ErrorType.Contains("Invalid download URLs") )
					{
						TabItem guiEditTab = this.FindControl<TabItem>("GuiEditTabItem");
						if ( guiEditTab != null )
							tabControl.SelectedItem = guiEditTab;
					}
					else
					{

						TabItem summaryTab = this.FindControl<TabItem>("SummaryTabItem");
						if ( summaryTab != null )
							tabControl.SelectedItem = summaryTab;
					}
				}
			}
			catch ( Exception ex )
			{
				Logger.LogException(ex, "Error in JumpToModButton_Click");
			}
		}
		#endregion
		#region URL Validation Helper Methods
		private static string GetUrlValidationReason([CanBeNull] string url)
		{
			return ValidationService.GetUrlValidationReason(url);
		}

		private bool _widescreenNotificationShown;

		private async Task<bool> ShowWidescreenNotificationAsync()
		{

			if ( _widescreenNotificationShown )
				return true;

			try
			{
				var dialog = new Dialogs.WidescreenNotificationDialog(MainConfig.WidescreenSectionContent);
				bool? result = await dialog.ShowDialog<bool?>(this);

				if ( dialog.DontShowAgain )
				{
					_widescreenNotificationShown = true;
				}

				return result == true && !dialog.UserCancelled;
			}
			catch ( Exception ex )
			{
				await Logger.LogErrorAsync($"Error showing widescreen notification: {ex.Message}");
				return true;
			}
		}

		#endregion
		private async void JumpToInstruction_Click([NotNull] object sender, [NotNull] RoutedEventArgs e)
		{
			if ( sender is Button button && button.Tag is Instruction instruction )
			{
				try
				{
					EditorMode = true;

					// Access the EditorTab control
					var editorTab = this.FindControl<Controls.EditorTab>("EditorTabControl");
					if ( editorTab == null )
					{
						Logger.LogWarning("EditorTabControl not found");
						return;
					}

					// Find the InstructionsExpander within EditorTab
					var instructionsExpander = editorTab.FindControl<Expander>("InstructionsExpander");
					ScrollViewer scrollViewer = ScrollNavigationService.FindScrollViewer(GuiEditTabItem);

					await ScrollNavigationService.NavigateToControlAsync(
						tabItem: GuiEditTabItem,
						expander: instructionsExpander,
						scrollViewer: scrollViewer,
						targetControl: MainWindow.FindInstructionEditorControl(instruction, editorTab)
					);
				}
				catch ( Exception ex )
				{
					Logger.LogException(ex, "Failed to jump to instruction");
				}
			}
		}

		[CanBeNull]
		private static InstructionEditorControl FindInstructionEditorControl(Instruction targetInstruction, Controls.EditorTab editorTab)
		{
			var instructionsRepeater = editorTab?.FindControl<ItemsRepeater>("InstructionsRepeater");
			if ( !(instructionsRepeater is null) )
			{
				return ScrollNavigationService.FindControlRecursive<InstructionEditorControl>(
					instructionsRepeater.Parent as Control,
					control =>
					{
						if ( control.DataContext is Instruction instruction &&
							   instruction.Guid == targetInstruction.Guid )
						{
							return true;
						}

						return false;
					});
			}
			return null;
		}
	}
}
#endregion